
                            < M A T L A B (R) >
                  Copyright 1984-2011 The MathWorks, Inc.
                    R2011b (7.13.0.564) 64-bit (glnxa64)
                              August 13, 2011

 
To get started, type one of these: helpwin, helpdesk, or demo.
For product information, visit www.mathworks.com.
 
Warning: Directory permission denied: /data/homes/gravio/matlab/draft/MTA/C3D. 
> In path at 110
  In addpath at 87
  In startup at 3
  In matlabrc at 199 
Warning: Directory permission denied:
/data/homes/gravio/matlab/draft/MTA/phase. 
> In path at 110
  In addpath at 87
  In startup at 3
  In matlabrc at 199 
>> addpath('/data/homes/shrisha/modules/matlab-emacs/toolbox','-begin'); rehash; emacsinit('emacsclient -n');
>> ls ../temp/
poolOffset_cntrs.mat

>> load ../temp/poolOffset_cntrs.mat
>> out1 = out

out1 = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]              []              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
              []              []              []
    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]              []              []

>>     out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
    nTrs = sum(~cellfun(@isempty, out), 2);
    out = out(nTrs > 1, :);
    nTrs = nTrs(nTrs > 1);
    % find pks of cntrs which are stable acorss sessions
    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf, locf] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        STABLE_CNTRS{mBase}  = cellfun(@sum, tf);
    end

    out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
>>     nTrs = sum(~cellfun(@isempty, out), 2);
>>     out = out(nTrs > 1, :);
>>     nTrs = nTrs(nTrs > 1);
>>     % find pks of cntrs which are stable acorss sessions
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf, locf] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        STABLE_CNTRS{mBase}  = cellfun(@sum, tf);
    end
>> 
>> out

out = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]    [1x1 struct]              []

>> SearchKenji

ans = 

    'ec013.931_942'      'ec013.935' 
    'ec013.931_942'      'ec013.937' 
    'ec013.944_958'      'ec013.948' 
    'ec013.961_974'      'ec013.970' 
    'ec013.961_974'      'ec013.971' 
    'ec013.961_974'      'ec013.972' 
    'ec016.682_688'      'ec016.682' 
    'ec016.694_711'      'ec016.698' 
    'ec016.715_735'      'ec016.722' 
    'ec016.853_867'      'ec016.860' 
    'ec016.871_889'      'ec016.880' 
    'ec016.893_911'      'ec016.896' 
    'ec016.893_911'      'ec016.899' 
    'ec016.914_932'      'ec016.923' 
    'ec016.1025_1048'    'ec016.1048'

>> 
>> gt1 = GenericTrial('ec013.931_942', 'ec013.935')

gt1 = 

  GenericTrial

  Properties:
           datasetType: 'kenji'
              filebase: 'ec013.931_942'
                 paths: [1x1 struct]
             trialName: 'ec013.935'
          trialPeriods: [7463481 9688632]
          trialSubType: []
            sampleRate: 20000
         lfpSampleRate: 1250
                   lfp: {}
                states: {[1x1 GenericState]}
                  maze: [1x1 struct]
    trackingSampleRate: 39.0625
              position: [69537x2x2 double]
        goodPosPeriods: [287 69281]
             pyrCluIdx: [1x74 double]
                   clu: []
                   res: []
                 elClu: []
                 elPos: [1x7 struct]
              pfObject: {}
                   ccg: {}


>> gt2 = GenericTrial('ec013.931_942', 'ec013.937')

gt2 = 

  GenericTrial

  Properties:
           datasetType: 'kenji'
              filebase: 'ec013.931_942'
                 paths: [1x1 struct]
             trialName: 'ec013.937'
          trialPeriods: [9688633 11342132]
          trialSubType: []
            sampleRate: 20000
         lfpSampleRate: 1250
                   lfp: {}
                states: {[1x1 GenericState]}
                  maze: [1x1 struct]
    trackingSampleRate: 39.0625
              position: [51672x2x2 double]
        goodPosPeriods: [325 51399]
             pyrCluIdx: [1x74 double]
                   clu: []
                   res: []
                 elClu: []
                 elPos: [1x7 struct]
              pfObject: {}
                   ccg: {}


>> gt1 = gt1.LoadPF

 loading rate maps ... 

gt1 = 

  GenericTrial

  Properties:
           datasetType: 'kenji'
              filebase: 'ec013.931_942'
                 paths: [1x1 struct]
             trialName: 'ec013.935'
          trialPeriods: [7463481 9688632]
          trialSubType: []
            sampleRate: 20000
         lfpSampleRate: 1250
                   lfp: {}
                states: {[1x1 GenericState]}
                  maze: [1x1 struct]
    trackingSampleRate: 39.0625
              position: [69537x2x2 double]
        goodPosPeriods: [287 69281]
             pyrCluIdx: [1x74 double]
                   clu: []
                   res: []
                 elClu: []
                 elPos: [1x7 struct]
              pfObject: [1x1 GenericPF]
                   ccg: {}


>> gt2 = gt2.LoadPF

 loading rate maps ... 

gt2 = 

  GenericTrial

  Properties:
           datasetType: 'kenji'
              filebase: 'ec013.931_942'
                 paths: [1x1 struct]
             trialName: 'ec013.937'
          trialPeriods: [9688633 11342132]
          trialSubType: []
            sampleRate: 20000
         lfpSampleRate: 1250
                   lfp: {}
                states: {[1x1 GenericState]}
                  maze: [1x1 struct]
    trackingSampleRate: 39.0625
              position: [51672x2x2 double]
        goodPosPeriods: [325 51399]
             pyrCluIdx: [1x74 double]
                   clu: []
                   res: []
                 elClu: []
                 elPos: [1x7 struct]
              pfObject: [1x1 GenericPF]
                   ccg: {}


>> load([gt.paths.analysis, gt.filebase, 'CA3.bigSquare.commonClus.mat']);
Undefined variable "gt" or function "gt.paths.analysis".
 
>> load([gt1.paths.analysis, gt1.filebase, 'CA3.bigSquare.commonClus.mat']);
Error using load
Unable to read file
/data/homes/shrisha/data/analysis/kenji/ec013.931_942/ec013.931_942CA3.bigSquare.commonClus.mat:
No such file or directory.
 
>> load([gt1.paths.analysis,'.CA3.bigSquare.commonClus.mat']);
Error using load
Unable to read file
/data/homes/shrisha/data/analysis/kenji/ec013.931_942/.CA3.bigSquare.commonClus.mat:
No such file or directory.
 
>> load([gt1.paths.analysis,'.CA3.bigSquare.commonClus.mat']);  C-c C-c
>> load([gt1.paths.analysis, gt1.filebase, 'CA3.bigSquare.commonClus.mat']);
Error using load
Unable to read file
/data/homes/shrisha/data/analysis/kenji/ec013.931_942/ec013.931_942CA3.bigSquare.commonClus.mat:
No such file or directory.
 
>> load([gt1.paths.analysis, gt1.filebase, '.CA3.bigSquare.commonClus.mat']);
>> commonClus

commonClus =

  Columns 1 through 13

     2     6    21    30    44    45    49    50    51    53    55    58    64

  Columns 14 through 17

    66    69    70    74

>> for i = 1 : 17
subplot(1, 2, 1)
imagesc(gt1.pfObject.rateMap{commonClus(i)});
subolot(1, 2, 2)
imagesc(gt2.pfObject.rateMap{commonClus(i)});  C-c C-c
>> for i = 1 : 17
subolot(1, 2, 2)
imagesc(gt2.pfObject.rateMap{commonClus(i)});
axis square
subolot(1, 2, 2)  C-c C-c
>> for i = 1 : 17
subplot(1, 2, 1)
imagesc(gt1.pfObject.rateMap{commonClus(i)});
axis square
subolot(1, 2, 2)
imagesc(gt2.pfObject.rateMap{commonClus(i)});
axis square
waitforbuttonpress
end
Undefined function 'subolot' for input arguments of type 'double'.
 
>> for i = 1 : 17
subplot(1, 2, 1)
imagesc(gt1.pfObject.rateMap{commonClus(i)});
axis square
subplot(1, 2, 2)
imagesc(gt2.pfObject.rateMap{commonClus(i)});
axis square
waitforbuttonpress
end
>> for i = 1 : 17
subplot(1, 2, 1)
imagesc(gt1.pfObject.rateMap{commonClus(i)}');
  C-c C-c
>> 



  C-c C-c
>> for i = 1 : 17  C-c C-c
>> for i = 1 : 17
subplot(1, 2, 1)
imagesc(gt1.pfObject.rateMap{commonClus(i)}');
axis square
subplot(1, 2, 2)
imagesc(gt2.pfObject.rateMap{commonClus(i)});
axis square
waitforbuttonpress
end
>> for i = 1 : 17
subplot(1, 2, 1)
imagesc(flipud(gt1.pfObject.rateMap{commonClus(i)}'));
axis square
subplot(1, 2, 2)
imagesc(gt2.pfObject.rateMap{commonClus(i)});
axis square
waitforbuttonpress
end
>> 
>> 
>> 
>> whos
  Name                Size              Bytes  Class              Attributes

  DetectCmnPks        1x1                  32  function_handle              
  STABLE_CNTRS        1x3                 736  cell                         
  ans                15x2                4026  cell                         
  cntrPeak            1x12               1776  cell                         
  cntrPeak1           1x12               1680  cell                         
  cntrPeak2           1x21               2864  cell                         
  cntrPeakNames       2x1                 258  cell                         
  commonClus          1x17                136  double                       
  evalStr             1x19                 38  char                         
  gt1                 1x1             4319693  GenericTrial                 
  gt2                 1x1             3642944  GenericTrial                 
  i                   1x1                   8  double                       
  lTr                 1x1                   8  double                       
  locf                1x12               1560  cell                         
  mBase               1x1                   8  double                       
  nTrs                3x1                  24  double                       
  out                 3x3              140064  cell                         
  out1               11x3              245368  cell                         
  tf                  1x12               1371  cell                         

>> gt
Error using >
Not enough input arguments.
 
>> gt1

gt1 = 

  GenericTrial

  Properties:
           datasetType: 'kenji'
              filebase: 'ec013.931_942'
                 paths: [1x1 struct]
             trialName: 'ec013.935'
          trialPeriods: [7463481 9688632]
          trialSubType: []
            sampleRate: 20000
         lfpSampleRate: 1250
                   lfp: {}
                states: {[1x1 GenericState]}
                  maze: [1x1 struct]
    trackingSampleRate: 39.0625
              position: [69537x2x2 double]
        goodPosPeriods: [287 69281]
             pyrCluIdx: [1x74 double]
                   clu: []
                   res: []
                 elClu: []
                 elPos: [1x7 struct]
              pfObject: [1x1 GenericPF]
                   ccg: {}


>> gt2

gt2 = 

  GenericTrial

  Properties:
           datasetType: 'kenji'
              filebase: 'ec013.931_942'
                 paths: [1x1 struct]
             trialName: 'ec013.937'
          trialPeriods: [9688633 11342132]
          trialSubType: []
            sampleRate: 20000
         lfpSampleRate: 1250
                   lfp: {}
                states: {[1x1 GenericState]}
                  maze: [1x1 struct]
    trackingSampleRate: 39.0625
              position: [51672x2x2 double]
        goodPosPeriods: [325 51399]
             pyrCluIdx: [1x74 double]
                   clu: []
                   res: []
                 elClu: []
                 elPos: [1x7 struct]
              pfObject: [1x1 GenericPF]
                   ccg: {}


>> whos
  Name                Size              Bytes  Class              Attributes

  DetectCmnPks        1x1                  32  function_handle              
  STABLE_CNTRS        1x3                 736  cell                         
  ans                15x2                4026  cell                         
  cntrPeak            1x12               1776  cell                         
  cntrPeak1           1x12               1680  cell                         
  cntrPeak2           1x21               2864  cell                         
  cntrPeakNames       2x1                 258  cell                         
  commonClus          1x17                136  double                       
  evalStr             1x19                 38  char                         
  gt1                 1x1             4319693  GenericTrial                 
  gt2                 1x1             3642944  GenericTrial                 
  i                   1x1                   8  double                       
  lTr                 1x1                   8  double                       
  locf                1x12               1560  cell                         
  mBase               1x1                   8  double                       
  nTrs                3x1                  24  double                       
  out                 3x3              140064  cell                         
  out1               11x3              245368  cell                         
  tf                  1x12               1371  cell                         

>> 
>> 
>>     selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)))
    selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)))
Undefined function 'filebases' for input arguments of type 'logical'.
 
>> roi ='CA3'

roi =

CA3

>> arena = 'bigSquare'
arena = 'bigSquare'

arena =

bigSquare

>>           sK.roi = roi;
          sK.arena = arena;
          filebases = SearchKenji(sK);
          filebases = unique(filebases(:, 1));

          sK.roi = roi;
>>           sK.arena = arena;
>>           filebases = SearchKenji(sK);
>>           filebases = unique(filebases(:, 1));
>> 
>>     selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)))

selectedFBs = 

    'ec013.931_942'
    'ec013.944_958'
    'ec013.961_974'

>> 
>> 
>> 
>> 
>> 
>> STABLE_CNTRS

STABLE_CNTRS = 

    [1x17 double]    [1x21 double]    [1x12 double]

>> tf

tf = 

  Columns 1 through 5

    [2x1 logical]    [3x1 logical]    [3x1 logical]    [1]    [4x1 logical]

  Columns 6 through 10

    [3x1 logical]    [2x1 logical]    [2x1 logical]    [1]    [3x1 logical]

  Columns 11 through 12

    [2x1 logical]    [1]

>> whos tf
  Name      Size            Bytes  Class    Attributes

  tf        1x12             1371  cell               

>> 
>> clear tf locf
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        STABLE_CNTRS{mBase}  = cellfun(@sum, tf);
    end

    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        STABLE_CNTRS{mBase}  = cellfun(@sum, tf);
    end
Error using cellfun
Undefined function 'sum' for input arguments of type 'cell'.
 
>> 
>>   for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        STABLE_CNTRS{mBase}  = cellfun(@sum, tf{mBase});
    end
>> tf

tf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> locf

locf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> locf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

>> cellfun(@sum, STABLE_CNTRS)

ans =

     2    18    11

>> STABLE_CNTRS{1}

ans =

  Columns 1 through 13

     0     0     0     0     0     0     0     0     0     0     0     0     1

  Columns 14 through 17

     0     0     0     1

>> locf{1}(end)

ans = 

    [2x1 double]

>> locf{1}{end}

ans =

     1
     0

>> out

out = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]    [1x1 struct]              []

>> 
>> 
>> 
>> tf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

>> cellfun(@sum, tf{1})

ans =

  Columns 1 through 13

     0     0     0     0     0     0     0     0     0     0     0     0     1

  Columns 14 through 17

     0     0     0     1

>> 
>> 
>> 
>> 
>> out{1}

ans = 

    cntrVertices: {1x17 cell}
       cntrPeals: {1x17 cell}

>> out{1}.cntrVertices

ans = 

  Columns 1 through 5

    {1x1 cell}    {1x0 cell}    {1x1 cell}    {1x1 cell}    {1x2 cell}

  Columns 6 through 11

    {1x3 cell}    {}    {1x3 cell}    {1x1 cell}    {1x1 cell}    {1x4 cell}

  Columns 12 through 17

    {}    {1x2 cell}    {1x1 cell}    {1x1 cell}    {1x2 cell}    {1x2 cell}

>> out{1}.cntrVertices(STABLE_CNTRS{1})
Subscript indices must either be real positive integers or logicals.
 
>> out{1}.cntrVertices(logical(STABLE_CNTRS{1}))

ans = 

    {1x2 cell}    {1x2 cell}

>> locf

locf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> locf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

>> locf(logical(STABLE_CNTRS{1}))
Index exceeds matrix dimensions.
 
>> locf(logical(STABLE_CNTRS{1}))  C-c C-c
>> STABLE_CNTRS{1}

ans =

  Columns 1 through 13

     0     0     0     0     0     0     0     0     0     0     0     0     1

  Columns 14 through 17

     0     0     0     1

>> locf{1}(logical(STABLE_CNTRS{1}))

ans = 

    [2x1 double]    [2x1 double]

>> 
>> commonClus(STABLE_CNTRS{1})
Subscript indices must either be real positive integers or logicals.
 
>> commonClus(logical(STABLE_CNTRS{1}))

ans =

    64    74

>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> out{mBase}.cntrVertices(logical(STABLE_CNTRS{mBase}))

ans = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x1 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x1 cell}    {1x3 cell}    {1x1 cell}

>> 
>> mBase

mBase =

     3

>> out{mBase}.cntrVertices(logical(STABLE_CNTRS{mBase}))  C-c C-c
>> mBase = 1

mBase =

     1

>> out{mBase}.cntrVertices(logical(STABLE_CNTRS{mBase}))

ans = 

    {1x2 cell}    {1x2 cell}

>> ans{1}

ans = 

    [29x2 double]    [31x2 double]

>> ans{2}

ans =

   35.0000   41.9464
   35.3357   41.0000
   35.3584   40.0000
   35.0484   39.0000
   35.0000   38.9206
   34.3482   38.0000
   34.0000   37.6797
   33.0000   37.1150
   32.6033   37.0000
   32.0000   36.8047
   31.0000   36.7175
   30.0000   36.8866
   29.7411   37.0000
   29.0000   37.3664
   28.3152   38.0000
   28.0000   38.6411
   27.8311   39.0000
   27.7788   40.0000
   28.0000   40.6716
   28.0958   41.0000
   28.7281   42.0000
   29.0000   42.2934
   29.8524   43.0000
   30.0000   43.1028
   31.0000   43.5889
   32.0000   43.7707
   33.0000   43.6739
   34.0000   43.1836
   34.2098   43.0000
   34.9802   42.0000
   35.0000   41.9464

>> 
>> 
>> out

out = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]    [1x1 struct]              []

>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> locf

locf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> locf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

>> locf{1}{end}

ans =

     1
     0

>> locf{1}(end)

ans = 

    [2x1 double]

>> locf{1}{end}

ans =

     1
     0

>> cntrPeaks
Undefined function or variable 'cntrPeaks'.
 
>> whos cntr*
  Name               Size            Bytes  Class    Attributes

  cntrPeak           1x12             1776  cell               
  cntrPeak1          1x12             1680  cell               
  cntrPeak2          1x21             2864  cell               
  cntrPeakNames      2x1               258  cell               

>> cntrPeak{logical(STABLE_CNTRS{1})}
Index exceeds matrix dimensions.
 
>> cntrPeak

cntrPeak = 

  Columns 1 through 4

    [2x2 double]    [3x2 double]    [3x2 double]    [1x2 double]

  Columns 5 through 8

    [4x2 double]    [3x2 double]    [2x2 double]    [2x2 double]

  Columns 9 through 12

    [1x2 double]    [3x2 double]    [2x2 double]    [1x2 double]

>> mBase

mBase =

     1

>> mBase= 3

mBase =

     3

>> locf

locf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> STABLE_CNTRS

STABLE_CNTRS = 

    [1x17 double]    [1x21 double]    [1x12 double]

>> cntrPeak{logical(STABLE_CNTRS{3})}

ans =

    32    31
    20    19


ans =

    42    25
    13    32
    29    21


ans =

    31    10


ans =

    23    48
    48    42
    36    46
    31     6


ans =

    16     3
    35     5


ans =

    12    46


ans =

    17    28
    27    22
    25    12


ans =

     5    46

>> cntrPeak{logical(STABLE_CNTRS{3})}  C-c C-c
>> locf

locf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> cntrPeak9logical(STABLE_CNTRS{3})
Undefined function 'cntrPeak9logical' for input arguments of type 'double'.
 
>> cntrPeak(logical(STABLE_CNTRS{3})
 cntrPeak(logical(STABLE_CNTRS{3})
                                 |
Error: Expression or statement is incorrect--possibly unbalanced (, {, or [.
 
>> cntrPeaks(logical(STABLE_CNTRS{3})
 cntrPeaks(logical(STABLE_CNTRS{3})
                                  |
Error: Expression or statement is incorrect--possibly unbalanced (, {, or [.
 
>> cntrPeaks(logical(STABLE_CNTRS{3}))
Undefined function 'cntrPeaks' for input arguments of type 'logical'.
 
>> cntrPeak(logical(STABLE_CNTRS{3}))

ans = 

  Columns 1 through 4

    [2x2 double]    [3x2 double]    [1x2 double]    [4x2 double]

  Columns 5 through 8

    [2x2 double]    [1x2 double]    [3x2 double]    [1x2 double]

>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> cntrPeak(logical(STABLE_CNTRS{3}))  C-c C-c
>>  for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            cntrVertices{mBase, mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            %            commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
        end
        
  end
>> whos cntr*
  Name               Size            Bytes  Class    Attributes

  cntrPeak           1x12             1776  cell               
  cntrPeak1          1x12             1680  cell               
  cntrPeak2          1x21             2864  cell               
  cntrPeakNames      2x1               258  cell               
  cntrVertices       3x3             73696  cell               

>> cntrVertices

cntrVertices = 

    {1x2  cell}    {1x2  cell}             []
    {1x16 cell}    {1x16 cell}    {1x16 cell}
    {1x8  cell}    {1x8  cell}             []

>> out

out = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]    [1x1 struct]              []

>> whos out
  Name      Size             Bytes  Class    Attributes

  out       3x3             140064  cell               

>> 
>> 
>> 
>> 
>> 
>> cellfun(@sum, STABLE_CNTRS)

ans =

     2    16     8

>> sum(ans)

ans =

    26

>> 
>> 
>> 
>> 
>> 
>> 
>> 
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            cntrVertices{mBase, mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
        end
        
  end
>> whos cntr*
  Name               Size            Bytes  Class    Attributes

  cntrPeak           1x12             1776  cell               
  cntrPeak1          1x12             1680  cell               
  cntrPeak2          1x21             2864  cell               
  cntrPeakNames      2x1               258  cell               
  cntrPeaks          3x3             10208  cell               
  cntrVertices       3x3             73696  cell               

>> 
>> cntrPeals
Undefined function or variable 'cntrPeals'.
 
>> cntrPeaks

cntrPeaks = 

    {1x2  cell}    {1x2  cell}             []
    {1x16 cell}    {1x16 cell}    {1x16 cell}
    {1x8  cell}    {1x8  cell}             []

>> cntrVertices

cntrVertices = 

    {1x2  cell}    {1x2  cell}             []
    {1x16 cell}    {1x16 cell}    {1x16 cell}
    {1x8  cell}    {1x8  cell}             []

>> 
>> cntrPeaks{1}

ans = 

    [2x2 double]    [2x2 double]

>> cntrPeaks{1}(1)

ans = 

    [2x2 double]

>> cntrPeaks{1}{1}

ans =

     4     8
    32    40

>> cntrPeaks{1}{2}

ans =

    41    26
    18    24

>> locf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

>> 
>> 
>> 
>> 
>> cntrPeaks{1}

ans = 

    [2x2 double]    [2x2 double]

>> locf{1}(STABLE_CNTRS{1})

ans = 

    [2x1 double]    [2x1 double]

>> idx = ans

idx = 

    [2x1 double]    [2x1 double]

>> idx{1}

ans =

     0
     1

>> idx{2}

ans =

     1
     0

>> 
>> 
>> cntrPeaks{1}

ans = 

    [2x2 double]    [2x2 double]

>> idx

idx = 

    [2x1 double]    [2x1 double]

>> 
>> idx

idx = 

    [2x1 double]    [2x1 double]

>> cellfun(@sum, idx)

ans =

     1     1

>> 
>> 
>> cntrPeaks{1}

ans = 

    [2x2 double]    [2x2 double]

>> 
>> 
>> 
>> cc= cntrPeaks{1}

cc = 

    [2x2 double]    [2x2 double]

>> cc{idx{1})
 cc{idx{1})
         |
Error: Unbalanced or unexpected parenthesis or bracket.
 
>> cc{idx{1}}
Subscript indices must either be real positive integers or logicals.
 
>> idx{1}

ans =

     0
     1

>> cc

cc = 

    [2x2 double]    [2x2 double]

>> cc{1}

ans =

     4     8
    32    40

>> cc{1}(idx{1})
Subscript indices must either be real positive integers or logicals.
 
>> cc{1}(idx{1},:)
Subscript indices must either be real positive integers or logicals.
 
>> 
>> 
>> 
>> 
>> 
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> out

out = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]              []              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
              []              []              []
    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]              []              []

>> 
>> 
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = locf{mBase}(STABLE_CNTRS);
            cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = cellfun(@sum, idx);
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
        end
    end

    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = locf{mBase}(STABLE_CNTRS);
            cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = cellfun(@sum, idx);
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
        end
    end
Undefined function 'nTrs' for input arguments of type 'double'.
 
>> 
>>    out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
    selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
    nTrs = sum(~cellfun(@isempty, out), 2);
    out = out(nTrs > 1, :);
    nTrs = nTrs(nTrs > 1);
    % find pks of cntrs which are stable acorss sessions
    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = locf{mBase}(STABLE_CNTRS);
            cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = cellfun(@sum, idx);
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
        end
    end

   out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
>>     selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
Undefined function 'filebases' for input arguments of type 'logical'.
 
>>     nTrs = sum(~cellfun(@isempty, out), 2);
>>     out = out(nTrs > 1, :);
>>     nTrs = nTrs(nTrs > 1);
>>     % find pks of cntrs which are stable acorss sessions
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = locf{mBase}(STABLE_CNTRS);
            cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = cellfun(@sum, idx);
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
        end
    end
Error using subsindex
Function 'subsindex' is not defined for values of class 'cell'.
 
>> 
>> 
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
%         for mTr = 1 : nTrs(mBase)
%             idx = locf{mBase}(STABLE_CNTRS);
%             cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
%             cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
%             % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
%             nStableCells = cellfun(@sum, idx);
% %             for kCell = 1 : nStableCells
% %                 kIdx = idx{kCell};
% %                 tempCntr = cntrVertices{kCell};
% %                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
% %             end
%         end
    end

    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
%         for mTr = 1 : nTrs(mBase)
%             idx = locf{mBase}(STABLE_CNTRS);
%             cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
%             cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
%             % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
%             nStableCells = cellfun(@sum, idx);
% %             for kCell = 1 : nStableCells
% %                 kIdx = idx{kCell};
% %                 tempCntr = cntrVertices{kCell};
% %                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
% %             end
%         end
    end
>> 
>> 
>>         for mTr = 1 : nTrs(mBase)
            idx = locf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = cellfun(@sum, idx);
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
%         end
    end

        for mTr = 1 : nTrs(mBase)
            idx = locf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = cellfun(@sum, idx);
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
%         end
    end
>> 
>> nStableCells

nStableCells =

     1     6     2     1     2     2     3     1

>> idx

idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>> locf

locf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> locf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

>> tf

tf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> 
>> 
>> nStableCells = cellfun(@sum, tf{mBase})

nStableCells =

     1     0     3     1     1     0     1     0     1     2     0     1

>> 
>> 
>> 
>> tf

tf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> help ismemberf

  function tf = ismemberf(A, S)
  [tf loc] = ismemberf(A, S)
 
  Purpose: Floating-point set member (i.e., with round-off tolerance)
 
  ISMEMBERF(A,S) for array A returns a logical array of the same size than
  A, contains TRUE for elements membership of set S.
  
  As opposed to Matlab buit-in function ISMEMBER (without trailing "F")
  which uses strict exact comparison between floats, ISMEMBERF allows some
  small tolerance while comparing elements of A and S.
 
  [TF,LOC] = ISMEMBERF(...) also returns an array LOC containing the
  index in S for each element in A which is a member of S and 0
  if there exists no such index.
  NOTE: The index corresponds to largest element of S within the tolerance.
        In case of drawing, the largest index is returned.
 
    ISMEMBERF(A, S, 'row') operates on rows of A and S (2D arrays)
       and returns true (1) if they match, false (0) otherwise.
    ISMEMBERF(..., 'tol', tol) select a suitable the tolerance
         - tol can be scalar or vector (using with 'row')
         - When tol is vector, each element is applied to a specific 
           column of A and S
         - If not provided, or NaN, tol is 1e-10 relative to variations
           and amplitude of S values (separated for each column of S;
           assuming both entries are double)
         - If one of the entry is single, the default tol is lowered to
           1e-5 (relative)
         - When tol is provided as zero, ISMEMBERF calls Matlab ISMEMBER()
         - x is member of S if there is an element S(loc) such that
                S(loc)-tol <= x < S(loc)+tol
 
  Examples:
 
  [tf, loc]=ismemberf(0.3, 0:0.1:1) % <- This returns 0 by ISMEMBER
 
  [X Y]=meshgrid(0:0.1:10,0:0.1:10);
   S=[3 1;
      3 3;
      5 6;
      5.2 5.5;
      3 3];
  A = [X(:) Y(:)];
  [tf loc]=ismemberf(A, S, 'row', 'tol', 0.5);
  imagesc(reshape(loc,size(X)));
 
  See also: ismember
 
  Author: Bruno Luong <brunoluong@yahoo.com>
    Original: 15/March/2009
    16/Mar, extend ISMEMBERF to complex arrays
    19/Mar: Rework on the engine with 'row' option
            Change default tol parameter
    10/Oct: Correct bug incorrect result for ismember([0 1],0) (line #271)
    13/Oct: change H1 line, correct a minor Bug
    23/Oct/2010: change H1 line
                 replace soon-deprecated "strmatch" with "strncmpi"

>> 
>> 
>> tf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

>> locf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

>> locf{1}}end}
 locf{1}}end}
       |
Error: Unbalanced or unexpected parenthesis or bracket.
 
>> locf{1}{end}

ans =

     1
     0

>> tf{1}{end}

ans =

     1
     0

>> cellfun(@sum, STABLE_CNTRS)

ans =

     2    16     8

>> tf{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

>> tf{2}{3}

ans =

     0
     0

>> tf{2}{4}

ans =

     0
     1

>> locf{2}{4}

ans =

     0
     1

>> locf{2}{5}

ans =

     1

>> locf{2}{6}

ans =

     1
     2

>> tf{2}{6}

ans =

     1
     1

>> 
>> mBase

mBase =

     3

>> out{2}

ans = 

    cntrVertices: {1x21 cell}
       cntrPeals: {1x21 cell}

>> out{2, 1}

ans = 

    cntrVertices: {1x21 cell}
       cntrPeals: {1x21 cell}

>> cc = out{2, 1}.cntrPeals

cc = 

  Columns 1 through 4

    [1x2 double]    [0x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [2x2 double]    [0x2 double]    [2x2 double]

  Columns 9 through 12

    [2x2 double]    [2x2 double]    [1x2 double]    [1x2 double]

  Columns 13 through 16

    [3x2 double]    [2x2 double]    [0x2 double]    [3x2 double]

  Columns 17 through 20

    [1x2 double]    [1x2 double]    [1x2 double]    [1x2 double]

  Column 21

    [1x2 double]

>> cc = out{2, 1}.cntrPeals  C-c C-c
>> cc{6}

ans =

    44    21
    10    18

>> locf{2}{6}

ans =

     1
     2

>> tf{2}{6}

ans =

     1
     1

>> help ismember
 ISMEMBER True for set member.
    ISMEMBER(A,S) for the array A returns an array of the same size as A
    containing 1 where the elements of A are in the set S and 0 otherwise.
    A and S can be cell arrays of strings.
 
    ISMEMBER(A,S,'rows') when A and S are matrices with the same
    number of columns returns a vector containing 1 where the rows of
    A are also rows of S and 0 otherwise.
 
    [TF,LOC] = ISMEMBER(...) also returns an array LOC containing the
    highest absolute index in S for each element in A which is a member of S
    and 0 if there is no such index.
 
    Class support for inputs A,S:
       float: double, single
 
    See also unique, intersect, setdiff, setxor, union.

    Overloaded methods:
       cell/ismember
       ordinal/ismember
       nominal/ismember
       categorical/ismember

    Reference page in Help browser
       doc ismember

>> idx

idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>> kIdx
Undefined function or variable 'kIdx'.
 
>> idx{1}

ans =

     0
     1

>> idx{2}

ans =

     1
     2
     3

>> STABLE_CNTRS{3}

ans =

     1     0     1     1     1     0     1     0     1     1     0     1

>> kIdx{1}
Undefined variable "kIdx" or class "kIdx".
 
>> idx{1}

ans =

     0
     1

>> cntrVertices

cntrVertices = 

    {1x8 cell}    {1x8 cell}

>> cntrVertices{idx}
Error using subsindex
Function 'subsindex' is not defined for values of class 'cell'.
 
>> cntrVertices{idx{1}}
Subscript indices must either be real positive integers or logicals.
 
>> cntrVertices{2}

ans = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x2 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x2 cell}    {1x2 cell}    {1x1 cell}

>> cntrVertices{1}

ans = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x1 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x1 cell}    {1x3 cell}    {1x1 cell}

>> 
>> 
>> 
>> 
>> cntrVertices

cntrVertices = 

    {1x8 cell}    {1x8 cell}

>> idx

idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>>             idx = locf{mBase}(STABLE_CNTRS{mBase})
            idx = locf{mBase}(STABLE_CNTRS{mBase})

idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>> cntrPeaks
cntrPeaks

cntrPeaks = 

    {1x8 cell}    {1x8 cell}

>> clear all
>> load ../temp/poolOffset_cntrs.mat
>>     out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
    selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
    nTrs = sum(~cellfun(@isempty, out), 2);
    out = out(nTrs > 1, :);
    nTrs = nTrs(nTrs > 1);
  C-c C-c
>> outo = out

outo = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]              []              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
    [1x1 struct]              []              []
              []              []              []
    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]              []              []

>>     out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
    selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
    nTrs = sum(~cellfun(@isempty, out), 2);
    out = out(nTrs > 1, :);
    nTrs = nTrs(nTrs > 1);

    out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
>>     selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
Undefined function 'filebases' for input arguments of type 'logical'.
 
>>     nTrs = sum(~cellfun(@isempty, out), 2);
>>     out = out(nTrs > 1, :);
>>     nTrs = nTrs(nTrs > 1);
>> 
>> outo =   C-c C-c
> >    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
%         for mTr = 1 : nTrs(mBase)
%             idx = locf{mBase}(STABLE_CNTRS{mBase});
%             cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
%             cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
%             % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
%             nStableCntrs = cellfun(@sum, tf{mBase});
% %             for kCell = 1 : nStableCells
% %                 kIdx = idx{kCell};
% %                 tempCntr = cntrVertices{kCell};
% %                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
% %             end
% %         end
    en  C-c C-c
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
%         for mTr = 1 : nTrs(mBase)
%             idx = locf{mBase}(STABLE_CNTRS{mBase});
%             cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
%             cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
%             % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
%             nStableCntrs = cellfun(@sum, tf{mBase});
% %             for kCell = 1 : nStableCells
% %                 kIdx = idx{kCell};
% %                 tempCntr = cntrVertices{kCell};
% %                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
% %             end
% %         end
    end  C-c C-c  C-c C-c
>> 
>> 
>> 
>> 
>> 
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
%         for mTr = 1 : nTrs(mBase)
%             idx = locf{mBase}(STABLE_CNTRS{mBase});
%             cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
%             cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
%             % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
%             nStableCntrs = cellfun(@sum, tf{mBase});
% %             for kCell = 1 : nStableCells
% %                 kIdx = idx{kCell};
% %                 tempCntr = cntrVertices{kCell};
% %                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
% %             end
% %         end
    end
>> STABLE_CNTRS

STABLE_CNTRS = 

    [1x17 logical]    [1x21 logical]    [1x12 logical]

>> mBase =1 

mBase =

     1

>> mBase = 3

mBase =

     3

>> STABLE_CNTRS{3}

ans =

     1     0     1     1     1     0     1     0     1     1     0     1

>> locf{3}

ans = 

  Columns 1 through 5

    [2x1 double]    [3x1 double]    [3x1 double]    [2]    [4x1 double]

  Columns 6 through 10

    [3x1 double]    [2x1 double]    [2x1 double]    [2]    [3x1 double]

  Columns 11 through 12

    [2x1 double]    [1]

>> STABLE_CNTRS{3}

ans =

     1     0     1     1     1     0     1     0     1     1     0     1

>> size(ans)

ans =

     1    12

>> idx = locf{mBase}(STABLE_CNTRS{mBase})

idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>> mTr
Undefined function or variable 'mTr'.
 
>> mTr = 1

mTr =

     1

>> 
>>     idx = locf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCntrs = cellfun(@sum, tf{mBase});
%
    
    idx = locf{mBase}(STABLE_CNTRS{mBase});
>>             cntrVertices{mTr} = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
>>             cntrPeaks{mTr} = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
>>             % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
>>             nStableCntrs = cellfun(@sum, tf{mBase});
>> %
>>     
>> cntrVertices

cntrVertices = 

    {1x8 cell}

>> out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase})

ans = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x1 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x1 cell}    {1x3 cell}    {1x1 cell}

>> cntrVertices{1}

ans = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x1 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x1 cell}    {1x3 cell}    {1x1 cell}

>> idx

idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>> idx{1}

ans =

     0
     1

>> cntrVertices{1}

ans = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x1 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x1 cell}    {1x3 cell}    {1x1 cell}

>> cntrVertices{1}{1}

ans = 

    [27x2 double]    [31x2 double]

>> nStableCntrs

nStableCntrs =

     1     0     3     1     1     0     1     0     1     2     0     1

>> tf

tf = 

    {1x17 cell}    {1x21 cell}    {1x12 cell}

>> tf{3}

ans = 

  Columns 1 through 5

    [2x1 logical]    [3x1 logical]    [3x1 logical]    [1]    [4x1 logical]

  Columns 6 through 10

    [3x1 logical]    [2x1 logical]    [2x1 logical]    [1]    [3x1 logical]

  Columns 11 through 12

    [2x1 logical]    [1]

>> nStableCntrs

nStableCntrs =

     1     0     3     1     1     0     1     0     1     2     0     1

>> STABLE_CNTRS{3}

ans =

     1     0     1     1     1     0     1     0     1     1     0     1

>> kCell = 1

kCell =

     1

>>                 kIdx = idx{kCell};

                kIdx = idx{kCell};
>> 
>> kIdx

kIdx =

     0
     1

>>                 tempCntr = cntrVertices{kCell};

                tempCntr = cntrVertices{kCell};
>> 
>> tempCntr

tempCntr = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x1 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x1 cell}    {1x3 cell}    {1x1 cell}

>> clear cntrVertices cntrPeaks
>>             cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});

            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
>>             cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
>> 
>> 
>>             cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});

            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
>>             cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
>> 
>> tempCntr

tempCntr = 

  Columns 1 through 5

    {1x2 cell}    {1x3 cell}    {1x1 cell}    {1x4 cell}    {1x2 cell}

  Columns 6 through 8

    {1x1 cell}    {1x3 cell}    {1x1 cell}

>> kIdx

kIdx =

     0
     1

>> 
>> nStableCntrs

nStableCntrs =

     1     0     3     1     1     0     1     0     1     2     0     1

>> 
>>             nStableCells = sum(STABLE_CNTRS{mBase})

nStableCells =

     8

>> idx


idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>>                 kIdx = idx{kCell};

    
                kIdx = idx{kCell};
>> 
>>     
>> kIdx

kIdx =

     0
     1

>>                 tempCntr = cntrVertices{kCell};

                tempCntr = cntrVertices{kCell};
>> 
>> tempCntr


tempCntr = 

    [27x2 double]    [31x2 double]

>>  tempCntr{kIdx}
Subscript indices must either be real positive integers or logicals.
 
>>  tempCntr(kIdx)
Subscript indices must either be real positive integers or logicals.
 
>> whos kIdx
  Name      Size            Bytes  Class     Attributes

  kIdx      2x1                16  double              

>> idx

idx = 

  Columns 1 through 6

    [2x1 double]    [3x1 double]    [2]    [4x1 double]    [2x1 double]    [2]

  Columns 7 through 8

    [3x1 double]    [1]

>> idx{1}

ans =

     0
     1

>> idx{23}
Index exceeds matrix dimensions.
 
>> idx{2}

ans =

     1
     2
     3

>>             idx = tf{mBase}(STABLE_CNTRS{mBase});

            idx = tf{mBase}(STABLE_CNTRS{mBase});
>> 
>>                 kIdx = idx{kCell};

                kIdx = idx{kCell};
>> 
>> kIdx

kIdx =

     0
     1

>> tempCntr(kIdx)

ans = 

    [31x2 double]

>> 
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>>     out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
    selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
    nTrs = sum(~cellfun(@isempty, out), 2);
    out = out(nTrs > 1, :);
    nTrs = nTrs(nTrs > 1);
    % find pks of cntrs which are stable acorss sessions
    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = tf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = sum(STABLE_CNTRS{mBase});
            nStableCntrs = cellfun(@sum, tf{mBase});
            for kCell = 1 : nStableCells
                kIdx = idx{kCell};
                tempCntr = cntrVertices{kCell};
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
            end
        end
    end

    
    out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
>>     selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
Undefined function 'filebases' for input arguments of type 'logical'.
 
>>     nTrs = sum(~cellfun(@isempty, out), 2);
>>     out = out(nTrs > 1, :);
>>     nTrs = nTrs(nTrs > 1);
>>     % find pks of cntrs which are stable acorss sessions
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = tf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = sum(STABLE_CNTRS{mBase});
            nStableCntrs = cellfun(@sum, tf{mBase});
            for kCell = 1 : nStableCells
                kIdx = idx{kCell};
                tempCntr = cntrVertices{kCell};
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
            end
        end
    end
Index exceeds matrix dimensions.
 
>> 
>>     
>> roi = 'CA3'

roi =

CA3

>> arena = 'bigSquare'

arena =

bigSquare

>>           sK.roi = roi;
          sK.arena = arena;
          filebases = SearchKenji(sK);
          filebases = unique(filebases(:, 1));
          

          sK.roi = roi;
>>           sK.arena = arena;
>>           filebases = SearchKenji(sK);
>>           filebases = unique(filebases(:, 1));
>>           
>> 
>>     out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
    selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
    nTrs = sum(~cellfun(@isempty, out), 2);
    out = out(nTrs > 1, :);
    nTrs = nTrs(nTrs > 1);
    % find pks of cntrs which are stable acorss sessions
    for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = tf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = sum(STABLE_CNTRS{mBase});
            nStableCntrs = cellfun(@sum, tf{mBase});
            for kCell = 1 : nStableCells
                kIdx = idx{kCell};
                tempCntr = cntrVertices{kCell};
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
            end
        end
    end

    out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
>>     selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
>>     nTrs = sum(~cellfun(@isempty, out), 2);
>>     out = out(nTrs > 1, :);
>>     nTrs = nTrs(nTrs > 1);
>>     % find pks of cntrs which are stable acorss sessions
>>     for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = tf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = sum(STABLE_CNTRS{mBase});
            nStableCntrs = cellfun(@sum, tf{mBase});
            for kCell = 1 : nStableCells
                kIdx = idx{kCell};
                tempCntr = cntrVertices{kCell};
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
            end
        end
    end
Index exceeds matrix dimensions.
 
>> 
>> 
>> >>     for mBase = 1 : size(out, 1)  C-c C-c
>>   C-c C-c
>> 
>> 
>> 
        for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = tf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = sum(STABLE_CNTRS{mBase});
            nStableCntrs = cellfun(@sum, tf{mBase});
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
        end


>>         for mBase = 1 : size(out, 1)
        DetectCmnPks = GenDetectCmnPks(nTrs(mBase), 'ismemberf', 3);
        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
        evalStr = [];
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
        [tf{mBase}, locf{mBase}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        %        nStableCntrs{mBase} = 
        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
        for mTr = 1 : nTrs(mBase)
            idx = tf{mBase}(STABLE_CNTRS{mBase});
            cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
            cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
            % commonCntrs.CntrPeaks{mBase, mTr} = out{mBase, mTr}.cntrPeaks(logical(STABLE_CNTRS{mBase}));
            nStableCells = sum(STABLE_CNTRS{mBase});
            nStableCntrs = cellfun(@sum, tf{mBase});
%             for kCell = 1 : nStableCells
%                 kIdx = idx{kCell};
%                 tempCntr = cntrVertices{kCell};
%                 cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
%             end
        end





end
>> 
>> 
>> 
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> dbstop if error
>> StableCntrs
Undefined function 'filebases' for input arguments of type 'logical'.

Error in StableCntrs (line 29)
    selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
 
29      selectedFBs = filebases(logical(sum(~cellfun(@isempty, out), 2)));
K>> dbquit
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 56)
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
 
56                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
K>> 
K>> kIdx

kIdx =

     0
     1

K>> tempCntr

tempCntr = 

    [33x2 double]

K>> cntrVertices

cntrVertices = 

    {1x1 cell}    {1x1 cell}

K>> kCell

kCell =

     1

K>> cntrVertices{1}

ans = 

    [33x2 double]

K>> cntrVertices{2}

ans = 

    [44x2 double]

K>> 
K>> 
K>> kIdx

kIdx =

     0
     1

K>> cntrVertices

cntrVertices = 

    {1x1 cell}    {1x1 cell}

K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

K>> idx[1}
 idx[1}
   |
Error: Unbalanced or unexpected parenthesis or bracket.
 
K>> idx{1}

ans =

     0
     1

K>> cntrVertices

cntrVertices = 

    {1x1 cell}    {1x1 cell}

K>> out{1}.cntrVertices

ans = 

  Columns 1 through 5

    {1x1 cell}    {1x0 cell}    {1x1 cell}    {1x1 cell}    {1x2 cell}

  Columns 6 through 11

    {1x3 cell}    {}    {1x3 cell}    {1x1 cell}    {1x1 cell}    {1x4 cell}

  Columns 12 through 17

    {}    {1x2 cell}    {1x1 cell}    {1x1 cell}    {1x2 cell}    {1x2 cell}

K>> tr
Undefined function or variable 'tr'.
 
K>> tf

tf = 

    {1x17 cell}

K>> tf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

K>> idx{1}

ans =

     0
     1

K>> idx{2}

ans =

     1
     0

K>> STABLE_CNTRS{1}

ans =

  Columns 1 through 13

     0     0     0     0     0     0     0     0     0     0     0     0     1

  Columns 14 through 17

     0     0     0     1

K>> STABLE_CNTRS{1}  C-c C-c
K>> tf{mBase}(13)

ans = 

    [2x1 logical]

K>> tf{mBase}{13}

ans =

     0
     1

K>> cntrVertices

cntrVertices = 

    {1x1 cell}    {1x1 cell}

K>> cntrVertices{1}

ans = 

    [33x2 double]

K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
dbquit
dbstop at 45 in StableCntrs.m
>> StableCntrs
45          STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
dbstep 1
46          for mTr = 1 : nTrs(mBase)
dbstep 1
47              idx = tf{mBase}(STABLE_CNTRS{mBase});
K>> tf

tf = 

    {1x17 cell}

K>> tf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

dbstep 1
48              cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

dbstep 1
49              cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
K>> cntrPeals
Undefined function or variable 'cntrPeals'.
 
K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

dbstep 1
51              nStableCells = sum(STABLE_CNTRS{mBase});
dbstep 1
52              nStableCntrs = cellfun(@sum, tf{mBase});
dbstep 1
53              for kCell = 1 : nStableCells
K>> nStableCells

nStableCells =

     2

K>> 
K>> 
K>> 
K>> 
K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

K>> idx{1}

ans =

     0
     1

K>> cntrVertices{1}

ans = 

    [29x2 double]    [31x2 double]

K>> nStableCells

nStableCells =

     2

dbstep 1
54                  kIdx = idx{kCell};
dbstep 1
55                  tempCntr = cntrVertices{kCell};
dbstep 1
56                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
K>> tempCntr

tempCntr = 

    [29x2 double]    [31x2 double]

K>> 
K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

K>> whos idx
  Name      Size            Bytes  Class    Attributes

  idx       1x2               228  cell               

K>> 
K>> whos kIdx
  Name      Size            Bytes  Class      Attributes

  kIdx      2x1                 2  logical              

K>>  tempCntr(idx)
Error using subsindex
Function 'subsindex' is not defined for values of class 'cell'.
 
K>>  tempCntr(k dx)
  tempCntr(k dx)
            |
Error: Unexpected MATLAB expression.
 
K>>  tempCntr(kIdx)

ans = 

    [31x2 double]

K>> 
K>> dbquit
>> clear ll
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 56)
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
 
56                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
K>> mBase

mBase =

     1

K>> kCell

kCell =

     1

K>> mBase

mBase =

     1

K>> mTr

mTr =

     2

K>> cmnCntrs

cmnCntrs = 

    cntrVertices: {[37x2 double]}

K>> tempCntr(kIdx)
Index exceeds matrix dimensions.
 
K>> kIdx

kIdx =

     0
     1

K>> tempCntr

tempCntr = 

    [33x2 double]

K>> dbquot
Undefined function or variable 'dbquot'.
 
dbquit
dbstop at 55 in StableCntrs.m
>> StableCntrs
55                  tempCntr = cntrVertices{kCell};
K>> kCell

kCell =

     1

K>> kIdx

kIdx =

     0
     1

K>> tempCntr

tempCntr = 

    [33x2 double]

K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

K>> cntrVertices{1}

ans = 

    [29x2 double]    [31x2 double]

K>> cntrVertices{2}

ans = 

    [37x2 double]    [27x2 double]

K>> mBase

mBase =

     1

K>> mTr

mTr =

     1

K>> whos tempCntr
  Name          Size            Bytes  Class    Attributes

  tempCntr      1x1               640  cell               

K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

K>> cntrVertices{1}

ans = 

    [29x2 double]    [31x2 double]

K>>                 tempCntr = cntrVertices{kCell}
                tempCntr = cntrVertices{kCell}

tempCntr = 

    [29x2 double]    [31x2 double]

dbstep 1
56                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
K>>                 tempCntr = cntrVertices{kCell}

tempCntr = 

    [29x2 double]    [31x2 double]

dbstep 1
57              end
K>>                 tempCntr = cntrVertices{kCell}

tempCntr = 

    [29x2 double]    [31x2 double]

K>>                 tempCntr = cntrVertices(kCell)

tempCntr = 

    {1x2 cell}

K>> whos tempCntr
  Name          Size            Bytes  Class    Attributes

  tempCntr      1x1              1296  cell               

K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
dbstop at 52 in StableCntrs.m
>> StableCntrs
52              nStableCntrs = cellfun(@sum, tf{mBase});
dbstep 1
53              for kCell = 1 : nStableCells
dbstep 1
54                  kIdx = idx{kCell};
dbstep 1
55                  tempCntr = cntrVertices{kCell};
dbstep 1
56                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
K>> tempCntr

tempCntr = 

    [29x2 double]    [31x2 double]

K>> kIdx

kIdx =

     0
     1

dbstep 1
57              end
dbstep 1
54                  kIdx = idx{kCell};
dbstep 1
55                  tempCntr = cntrVertices{kCell};
dbstep 1
56                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
K>> tempCntr

tempCntr = 

    [37x2 double]    [27x2 double]

dbstep 1
57              end
dbstep 1
58          end
dbstep 1
47              idx = tf{mBase}(STABLE_CNTRS{mBase});
dbstep 1
48              cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
dbstop at 52 in StableCntrs.m
dbcont
52              nStableCntrs = cellfun(@sum, tf{mBase});
dbstep 1
53              for kCell = 1 : nStableCells
dbstep 1
54                  kIdx = idx{kCell};
dbstep 1
55                  tempCntr = cntrVertices{kCell};
dbstep 1
56                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr{kIdx};
K>> tempCntr

tempCntr = 

    [33x2 double]

K>> kCell

kCell =

     1

K>> kIdx

kIdx =

     0
     1

K>> mTr

mTr =

     2

K>> kCell

kCell =

     1

K>> cntrVertices

cntrVertices = 

    {1x1 cell}    {1x1 cell}

K>> kIdx

kIdx =

     0
     1

K>> cntrPeals
Undefined function or variable 'cntrPeals'.
 
K>> cntrPeaks

cntrPeaks = 

    [1x2 double]    [1x2 double]

K>> 
K>> 
K>> doc ismemberf
K>> \
 \
|
Error: Unexpected MATLAB operator.
 
K>> 
K>> 
K>> clear all
K>> [tf, loc] = ismemberf([1 2 3], [ 1 2])

tf =

     1     1     0


loc =

     1     2     0

K>> 
dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 57)
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
 
57                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
dbstop at 54 in StableCntrs.m
K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
dbstop at 52 in StableCntrs.m
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
52              nStableCntrs = cellfun(@sum, tf{mBase});
dbstep 1
53              for kCell = 1 : nStableCells
dbstep 1
54                  kIdx = idx{kCell};
dbstep 1
55                  kIdx(kIdx == 0) = [];
K>> kIdx

kIdx =

     0
     1

K>> locf

locf = 

    {1x17 cell}

K>> idx

idx = 

    [2x1 double]    [2x1 double]

K>> idx{1}

ans =

     0
     1

K>> findans)
 findans)
       |
Error: Unbalanced or unexpected parenthesis or bracket.
 
K>> find(ans)

ans =

     2

K>> 
K>> dbquit
dbstop at 52 in StableCntrs.m
>> StableCntrs
Undefined function 'find' for input arguments of type 'cell'.

Error in StableCntrs (line 47)
            idx = find(locf{mBase}(STABLE_CNTRS{mBase}));
 
47              idx = find(locf{mBase}(STABLE_CNTRS{mBase}));
K>> dbquit
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 57)
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
 
57                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
dbstop at 53 in StableCntrs.m
K>> dbquit
dbstop at 53 in StableCntrs.m
>> StableCntrs
53              for kCell = 1 : nStableCells
dbstep 1
54                  kIdx = find(idx{kCell});
dbstep 1
55                  kIdx(kIdx == 0) = [];
K>> kIdx

kIdx =

     2

K>> 
dbstep 1
56                  tempCntr = cntrVertices{kCell};
K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

K>> kCell

kCell =

     1

dbstep 1
57                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
K>> tempCntr

tempCntr = 

    [29x2 double]    [31x2 double]

K>> whos kIdx
  Name      Size            Bytes  Class     Attributes

  kIdx      1x1                 8  double              

K>> kIdx

kIdx =

     2

K>> tempCntr(2)

ans = 

    [31x2 double]

dbstep 1
58              end
dbstep 1
54                  kIdx = find(idx{kCell});
dbstep 1
55                  kIdx(kIdx == 0) = [];
K>> kIdx

kIdx =

     1

dbstep 1
56                  tempCntr = cntrVertices{kCell};
dbstep 1
57                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

K>> cntrVertices{2}

ans = 

    [37x2 double]    [27x2 double]

dbstep 1
58              end
K>> tempCntr

tempCntr = 

    [37x2 double]    [27x2 double]

K>> kIdx

kIdx =

     1

dbstep 1
59          end
dbstep 1
47              idx = locf{mBase}(STABLE_CNTRS{mBase});
dbstep 1
48              cntrVertices = out{mBase, mTr}.cntrVertices(STABLE_CNTRS{mBase});
K>> idx

idx = 

    [2x1 double]    [2x1 double]

K>> 
dbstep 1
49              cntrPeaks = out{mBase, mTr}.cntrPeals(STABLE_CNTRS{mBase});
dbstep 1
51              nStableCells = sum(STABLE_CNTRS{mBase});
dbstep 1
52              nStableCntrs = cellfun(@sum, tf{mBase});
dbstep 1
53              for kCell = 1 : nStableCells
dbstep 1
54                  kIdx = find(idx{kCell});
dbstep 1
55                  kIdx(kIdx == 0) = [];
K>> kIdx

kIdx =

     2

dbstep 1
56                  tempCntr = cntrVertices{kCell};
K>> cntrVertices

cntrVertices = 

    {1x1 cell}    {1x1 cell}

K>> kCell

kCell =

     1

dbstep 1
57                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
K>> tempCntr

tempCntr = 

    [33x2 double]

K>> kIdx

kIdx =

     2

K>> mTr

mTr =

     2

K>> idx{kCell}

ans =

     0
     1

K>>                 kIdx = idx{kCell};

                kIdx = idx{kCell};
K>> 
K>> kIdx

kIdx =

     0
     1

K>> 
K>> tf{mBase}(dbquit
 tf{mBase}(dbquit
                |
Error: Expression or statement is incorrect--possibly unbalanced (, {, or [.
 
dbquit
>> [tf, loc] = ismemberf([1 2 3], [ 1 2])

tf =

     1     1     0


loc =

     1     2     0

>> [tf, loc] = ismemberf([9 2 3], [ 1 2])

tf =

     0     1     0


loc =

     0     2     0

>> a = [9 1]

a =

     9     1

>> b = [1]

b =

     1

>> [tf, loc] = ismemberf(a, b)

tf =

     0     1


loc =

     0     1

>> [tf, loc] = ismember(a, b)

tf =

     0     1


loc =

     0     1

>> b(loc)
Subscript indices must either be real positive integers or logicals.
 
>> b = [1 2]

b =

     1     2

>> a = [9 1 3]

a =

     9     1     3

>> [tf, loc] = ismember(a, b)

tf =

     0     1     0


loc =

     0     1     0

>> b = [2 1]

b =

     2     1

>> [tf, loc] = ismember(a, b)

tf =

     0     1     0


loc =

     0     2     0

>> 
>> c = [ 3 2 1]

c =

     3     2     1

>> [tf, loc] = ismember(a, b, c)
Error using ismember (line 168)
Unknown flag.
 
168             error(message('MATLAB:ISMEMBER:UnknownFlag'));
K>> dbquot
Undefined function or variable 'dbquot'.
 
K>> dbquit
>> 
>> [tf, loc] = ismemberf(a, b, c)

tf =

     0     1     0


loc =

     0     2     0

>> 
>> 
>> 
>> [tf, loc] = ismemberf(a, b, b)

tf =

     0     1     0


loc =

     0     2     0

>> [tf, loc] = ismemberf(a, c, b)

tf =

     0     1     1


loc =

     0     3     1

>> intersect(a,b)

ans =

     1

>> intersect(a,b,c)
Error using intersect (line 164)
Unknown flag.
 
164             error(message('MATLAB:INTERSECT:UnknownFlag'));
K>> dbquit
>> 
>> 
>> 
>> 
>> out

out = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]    [1x1 struct]              []

>> out.cntrPeals
Attempt to reference field of non-structure array.
 
>> out.cntrPeaks
Attempt to reference field of non-structure array.
 
>> out{1}.cntrPeaks
Reference to non-existent field 'cntrPeaks'.
 
>> out{1}.cntrPeals

ans = 

  Columns 1 through 4

    [1x2 double]    [0x2 double]    [1x2 double]    [1x2 double]

  Columns 5 through 8

    [2x2 double]    [3x2 double]    [0x2 double]    [3x2 double]

  Columns 9 through 12

    [1x2 double]    [1x2 double]    [4x2 double]    [0x2 double]

  Columns 13 through 16

    [2x2 double]    [1x2 double]    [1x2 double]    [2x2 double]

  Column 17

    [2x2 double]

>> intersect(a,b)

ans =

     1

>> a

a =

     9     1     3

>> b

b =

     2     1

>> 
>> 
>> 
>> 
>> 
>> nchoosek([1 : 3], 2)

ans =

     1     2
     1     3
     2     3

>> 
>> l{1} = [1 0]

l = 

    [1x2 double]

>> l{2} = [0 1]\
 l{2} = [0 1]\
             |
Error: Expression or statement is incomplete or incorrect.
 
>> l{2} = [0 1]

l = 

    [1x2 double]    [1x2 double]

>> cellfun(@or, l(1), l2())
Undefined function or variable 'l2'.
 
>> cellfun(@or, l(1), l(2))
Error using cellfun
Non-scalar in Uniform output, at index 1, output 1.
Set 'UniformOutput' to false.
 
>> cellfun(@or, l(1), l(2),'uniformoutput',0)

ans = 

    [1x2 logical]

>> ans{1}

ans =

     1     1

>> cellfun(@or, l, 'uniformoutput',0)
Error using |
Not enough input arguments.
 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> !fg
/bin/bash: line 0: fg: no job control
>> !jobs
>> 
>> whos
  Name               Size             Bytes  Class                 Attributes

  DetectCmnPks       1x1                 32  function_handle                 
  STABLE_CNTRS       1x1                129  cell                            
  a                  1x3                 24  double                          
  ans                0x1                     java.lang.String[]              
  b                  1x2                 16  double                          
  c                  1x3                 24  double                          
  cmnCntrs           1x1                992  struct                          
  cntrPeak           1x17              2304  cell                            
  cntrPeak1          1x17              2272  cell                            
  cntrPeakNames      2x1                258  cell                            
  cntrPeaks          1x2                256  cell                            
  cntrVertices       1x2               1680  cell                            
  evalStr            1x19                38  char                            
  idx                1x2                256  cell                            
  kCell              1x1                  8  double                          
  kIdx               2x1                 16  double                          
  l                  1x2                256  cell                            
  lTr                1x1                  8  double                          
  loc                1x3                 24  double                          
  locf               1x1               2216  cell                            
  mBase              1x1                  8  double                          
  mTr                1x1                  8  double                          
  nStableCells       1x1                  8  double                          
  nStableCntrs       1x17               136  double                          
  nTrs               3x1                 24  double                          
  out                3x3             140064  cell                            
  tempCntr           1x1                640  cell                            
  tf                 1x3                  3  logical                         

>>         nTrPairs = nchoosek(1 : nTrs(mBase), 2);

    
        nTrPairs = nchoosek(1 : nTrs(mBase), 2);
>> 
>>     
>> nTrs

nTrs =

     2
     3
     2

>> nTrPairs

nTrPairs =

     1     2

>> 
>>  for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end
Undefined function or variable 'trPairs'.
 
>> 
>>         trPairs = nchoosek(1 : nTrs(mBase), 2);

        trPairs = nchoosek(1 : nTrs(mBase), 2);
>> 
>>  for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end
>> 
>> kTF

kTF = 

    {1x17 cell}

>> kLoc

kLoc = 

    {1x17 cell}

>> out

out = 

    [1x1 struct]    [1x1 struct]              []
    [1x1 struct]    [1x1 struct]    [1x1 struct]
    [1x1 struct]    [1x1 struct]              []

>> mBase

mBase =

     1

>> mBase = 2

mBase =

     2

>>         trPairs = nchoosek(1 : nTrs(mBase), 2);
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            %    evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end

        trPairs = nchoosek(1 : nTrs(mBase), 2);
>>         for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            %    evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
Index exceeds matrix dimensions.
 
>> 
>>   C-c C-c
>> 
>> trPairs

trPairs =

     1     2
     1     3
     2     3

>> nTrs

nTrs =

     2
     3
     2

>> 
>> 
>>         cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));

        cntrPeakNames = genvarname(cellstr(repmat('cntrPeak', nTrs(mBase), 1)));
>> 
>>         for lTr = 1 : nTrs(mBase)

  C-c C-c
>>         for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            %    evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end

    
        for lTr = 1 : nTrs(mBase)
            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeals;']);
            %            eval([cntrPeakNames{lTr} '=out{mBase, lTr}.cntrPeaks;']);
            %    evalStr = [evalStr, ',' cntrPeakNames{lTr}];
        end
>> 
>>     
>>         for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end

        for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end
Index exceeds matrix dimensions.
 
>> 
>> kTF

kTF = 

    {1x21 cell}

>> kTrPr

kTrPr =

     2

>> clear kTF kLoc
>>         for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end

        for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end
Index exceeds matrix dimensions.
 
>> 
>> DetectCmnPks

DetectCmnPks = 

    @(A1,A2)ismemberf(A1,A2,'row','tol',3)

>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Undefined function 'nTrPairs' for input arguments of type 'double'.

Error in StableCntrs (line 47)
                evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
 
47                  evalStr = [evalStr, ',' cntrPeakNames{nTrPairs(kTrPr, kPr)}];
K>> nTrPairs
Undefined function or variable 'nTrPairs'.
 
K>> dbquit
>> StableCntrs
Error using @(A1,A2,A3)ismemberf(A1,A2,A3,'row','tol',3)
Not enough input arguments.

Error in StableCntrs (line 49)
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr,
            ',', '''uniformoutput''' ', 0);']);
 
dbquit
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 69)
                cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
 
69                  cmnCntrs.cntrVertices{mBase, mTr} = tempCntr(kIdx);
K>> kYF
Undefined function or variable 'kYF'.
 
K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}    {1x21 cell}

K>> mBase

mBase =

     2

K>> kTF{1}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> kTF{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> kTF{3}

ans = 

  Columns 1 through 7

    [3x1 logical]    [2x1 logical]    [0]    [1]    [1]    [2x1 logical]    [1]

  Columns 8 through 15

    [2x1 logical]    [0]    [0]    [1]    [0]    [2x1 logical]    [1]    [0]

  Columns 16 through 21

    [0]    [0]    [2x1 logical]    [1]    [1]    [1]

K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}    {1x21 cell}

K>> cellfun(@or, kTF) 
Error using cellfun
Undefined function 'or' for input arguments of type 'cell'.
 
K>> cellfun(@and, kTF) 
Error using cellfun
Undefined function 'and' for input arguments of type 'cell'.
 
K>> cellfun(@and, kTF{1}, kTF{2}) 
Error using cellfun
Non-scalar in Uniform output, at index 2, output 1.
Set 'UniformOutput' to false.
 
K>> cellfun(@and, kTF{1}, kTF{2},'uniformoutput', 0) 

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> kTF{1}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> kTF{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> kTF{3}

ans = 

  Columns 1 through 7

    [3x1 logical]    [2x1 logical]    [0]    [1]    [1]    [2x1 logical]    [1]

  Columns 8 through 15

    [2x1 logical]    [0]    [0]    [1]    [0]    [2x1 logical]    [1]    [0]

  Columns 16 through 21

    [0]    [0]    [2x1 logical]    [1]    [1]    [1]

K>> cellfun(@and, kTF{1}, kTF{2},kTF{3},'uniformoutput', 0) 
Error using &
Too many input arguments.
 
K>> cellfun(@AND, kTF{1}, kTF{2},kTF{3},'uniformoutput', 0) 
Error using cellfun
Undefined function 'AND' for input arguments of type 'logical'.
 
K>> cellfun(@and, kTF{1}, kTF{2},kTF{3},'uniformoutput', 0) 
Error using &
Too many input arguments.
 
K>> cellfun(@and, kTF{1}, kTF{2},'uniformoutput', 0) 

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> temp = cellfun(@and, kTF{1}, kTF{2},'uniformoutput', 0) ;
K>> cellfun(@and, temp, kTF{3},'uniformoutput', 0) 
Error using &
Inputs must have the same size.
 
K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}    {1x21 cell}

K>> kTF{1}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> kTF{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> kTF{3}

ans = 

  Columns 1 through 7

    [3x1 logical]    [2x1 logical]    [0]    [1]    [1]    [2x1 logical]    [1]

  Columns 8 through 15

    [2x1 logical]    [0]    [0]    [1]    [0]    [2x1 logical]    [1]    [0]

  Columns 16 through 21

    [0]    [0]    [2x1 logical]    [1]    [1]    [1]

K>> cellfun(@and, temp, kTF{3},'uniformoutput', 0)   C-c C-c
K>> cellfun(@and, kTF{1}, kTF{3},'uniformoutput', 0) 
Error using &
Inputs must have the same size.
 
K>> kTF{1}(1)

ans = 

    [0]

K>> kTF{3}(1)

ans = 

    [3x1 logical]

K>> kTF{3}{1}

ans =

     0
     0
     0

K>> 
K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}    {1x21 cell}

K>> kTF{3}

ans = 

  Columns 1 through 7

    [3x1 logical]    [2x1 logical]    [0]    [1]    [1]    [2x1 logical]    [1]

  Columns 8 through 15

    [2x1 logical]    [0]    [0]    [1]    [0]    [2x1 logical]    [1]    [0]

  Columns 16 through 21

    [0]    [0]    [2x1 logical]    [1]    [1]    [1]

K>> 
K>> 
K>> 
K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}    {1x21 cell}

K>> kTF{1}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> 
K>> kTF{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> trPairs

trPairs =

     1     2
     1     3
     2     3

K>> nchoosek(1:4, 2)

ans =

     1     2
     1     3
     1     4
     2     3
     2     4
     3     4

K>> ans(ans(:, 1) ~= 1 ,:) = [] 

ans =

     1     2
     1     3
     1     4

K>> 
K>> ans(ans(:, 1) ~= 1 ,:) = []   C-c C-cans(ans(:, 1) ~= 1 ,:) = []   C-c C-c
 ans(ans(:, 1) ~= 1 ,:) = []   C-c C-cans(ans(:, 1) ~= 1 ,:) = []   C-c C-c
                              |
Error: Unexpected MATLAB expression.
 
K>> 
K>> 
K>> 
K>> 
K>> 
K>>         trPairs(trPairs(:, 1) ~= 1 ,:) = [] ;

    trPairs
        trPairs(trPairs(:, 1) ~= 1 ,:) = [] ;
K>> 
K>>     trPairs

trPairs =

     1     2
     1     3

K>> 
K>>         for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{trPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end

        for kTrPr = 1 : size(trPairs, 1)
            evalStr = [];
            for kPr = 1 : 2
                evalStr = [evalStr, ',' cntrPeakNames{trPairs(kTrPr, kPr)}];
            end
            [kTF{kTrPr}, kLoc{kTrPr}] = eval(['cellfun(DetectCmnPks' evalStr, ',', '''uniformoutput''' ', 0);']);
        end
K>> 
K>> kTrPr

kTrPr =

     2

K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}    {1x21 cell}

K>> nTrPairs
Undefined function or variable 'nTrPairs'.
 
K>> trPairs

trPairs =

     1     2
     1     3

K>> kTF(3)  = []

kTF = 

    {1x21 cell}    {1x21 cell}

K>> cellfun(@and, kTF{1}, kTF{2},'uniformoutput', 0) 

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> cellfun(@and, kTF{1}, kTF{2},'uniformoutput', 0)   C-c C-c
K>> 
K>> 
K>> cellfun
Error using cellfun
Not enough input arguments.
 
K>> 
K>> 
K>> 
K>> 
K>>         tf{mBase} = repmat({false}, 1, length(kTF{1}));

        tf{mBase} = repmat({false}, 1, length(kTF{1}));
K>> 
K>> tf

tf = 

    {1x17 cell}    {1x21 cell}

K>> tf{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

K>> 
K>> clear tf
K>>         tf{mBase} = repmat({false}, 1, length(kTF{1}));

        tf{mBase} = repmat({false}, 1, length(kTF{1}));
K>> 
K>> tf

tf = 

    []    {1x21 cell}

K>> tf{2}

ans = 

  Columns 1 through 11

    [0]    [0]    [0]    [0]    [0]    [0]    [0]    [0]    [0]    [0]    [0]

  Columns 12 through 21

    [0]    [0]    [0]    [0]    [0]    [0]    [0]    [0]    [0]    [0]

K>> length(kTF{1})

ans =

    21

K>> kTF{1}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> 
K>> 
K>> 
K>> 
K>> 
K>> trPairs

trPairs =

     1     2
     1     3

K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}

K>> mBase

mBase =

     2

K>> mTr

mTr =

     1

K>> mTrPr
Undefined function or variable 'mTrPr'.
 
K>> 
K>> 
K>>         nTrPairs = size(trPairs, 1);

        nTrPairs = size(trPairs, 1);
K>> 
K>> nTrPairs

nTrPairs =

     2

K>> 
K>> 
K>> 
K>> 
K>> 
K>> clear tf
K>>         nTrPairs = size(trPairs, 1);
        for mTrPr = 1 : nTrPairs - 1
            if mTfPr == 1
                tf{mBase} = cellfun(@and, kTF{mTfPr}, kTF{mTfPr + 1}); 
            else
                tfB{mBase} = cellfun(@and, tf{mBase}, kTF{mTfPr + 1});
            end
        end

        nTrPairs = size(trPairs, 1);
K>>         for mTrPr = 1 : nTrPairs - 1
            if mTfPr == 1
                tf{mBase} = cellfun(@and, kTF{mTfPr}, kTF{mTfPr + 1}); 
            else
                tfB{mBase} = cellfun(@and, tf{mBase}, kTF{mTfPr + 1});
            end
        end
Undefined function or variable 'mTfPr'.
 
K>> 
K>> 
K>>         for mTrPr = 1 : nTrPairs - 1
            if mTrPr == 1
                tf{mBase} = cellfun(@and, kTF{mTfPr}, kTF{mTfPr + 1}); 
            else
                tfB{mBase} = cellfun(@and, tf{mBase}, kTF{mTfPr + 1});
            end
        end

        for mTrPr = 1 : nTrPairs - 1
            if mTrPr == 1
                tf{mBase} = cellfun(@and, kTF{mTfPr}, kTF{mTfPr + 1}); 
            else
                tfB{mBase} = cellfun(@and, tf{mBase}, kTF{mTfPr + 1});
            end
        end
Undefined function or variable 'mTfPr'.
 
K>> 
K>>         for mTrPr = 1 : nTrPairs - 1
            if mTrPr == 1
                tf{mBase} = cellfun(@and, kTF{mTrPr}, kTF{mTrPr + 1}); 
            else
                tfB{mBase} = cellfun(@and, tf{mBase}, kTF{mTrPr + 1});
            end
        end
Error using cellfun
Non-scalar in Uniform output, at index 2, output 1.
Set 'UniformOutput' to false.
 
K>>         for mTrPr = 1 : nTrPairs - 1
            if mTrPr == 1
                tf{mBase} = cellfun(@and, kTF{mTrPr}, kTF{mTrPr + 1}, 'UNIFORMOUTPUT', 0); 
            else
                tfB{mBase} = cellfun(@and, tf{mBase}, kTF{mTrPr + 1},'UNIFORMOUTPUT', 0);
            end
        end

        for mTrPr = 1 : nTrPairs - 1
            if mTrPr == 1
                tf{mBase} = cellfun(@and, kTF{mTrPr}, kTF{mTrPr + 1}, 'UNIFORMOUTPUT', 0); 
            else
                tfB{mBase} = cellfun(@and, tf{mBase}, kTF{mTrPr + 1},'UNIFORMOUTPUT', 0);
            end
        end
K>> 
K>> tf

tf = 

    []    {1x21 cell}

K>> mBase

mBase =

     2

K>> tf{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> cellfun(@sum, tf{2})

ans =

  Columns 1 through 13

     0     0     0     1     1     2     0     2     0     0     1     1     1

  Columns 14 through 21

     1     0     0     1     1     1     1     1

K>> cellfun(@sum, tf{2})  C-c C-c
K>> tf{2}{6}

ans =

     1
     1

K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> cntrPeakNames

cntrPeakNames = 

    'cntrPeak'
    'cntrPeak1'
    'cntrPeak2'

K>> cntrPeak

cntrPeak = 

  Columns 1 through 4

    [1x2 double]    [0x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [2x2 double]    [0x2 double]    [2x2 double]

  Columns 9 through 12

    [2x2 double]    [2x2 double]    [1x2 double]    [1x2 double]

  Columns 13 through 16

    [3x2 double]    [2x2 double]    [0x2 double]    [3x2 double]

  Columns 17 through 20

    [1x2 double]    [1x2 double]    [1x2 double]    [1x2 double]

  Column 21

    [1x2 double]

K>> tf

tf = 

    []    {1x21 cell}

K>> tf{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> 
K>> cp1 = cntrPeak(  C-c C-c
K>>         STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));

        STABLE_CNTRS{mBase}  = logical(cellfun(@sum, tf{mBase}));
K>> 
K>> cp1 = cntrPeak(STABLE_CNTRS{2})

cp1 = 

  Columns 1 through 4

    [2x2 double]    [1x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [1x2 double]    [3x2 double]    [2x2 double]

  Columns 9 through 12

    [1x2 double]    [1x2 double]    [1x2 double]    [1x2 double]

  Column 13

    [1x2 double]

K>> cp2 = cntrPeak1(STABLE_CNTRS{2})

cp2 = 

  Columns 1 through 4

    [1x2 double]    [1x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [1x2 double]    [2x2 double]    [1x2 double]

  Columns 9 through 12

    [1x2 double]    [2x2 double]    [1x2 double]    [1x2 double]

  Column 13

    [1x2 double]

K>> cp3 = cntrPeak1(STABLE_CNTRS{3})
Index exceeds matrix dimensions.
 
K>> cp3 = cntrPeak1(STABLE_CNTRS{2})

cp3 = 

  Columns 1 through 4

    [1x2 double]    [1x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [1x2 double]    [2x2 double]    [1x2 double]

  Columns 9 through 12

    [1x2 double]    [2x2 double]    [1x2 double]    [1x2 double]

  Column 13

    [1x2 double]

K>> whos cp*
  Name      Size            Bytes  Class    Attributes

  cp1       1x13             1760  cell               
  cp2       1x13             1728  cell               
  cp3       1x13             1728  cell               

K>> cp1

cp1 = 

  Columns 1 through 4

    [2x2 double]    [1x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [1x2 double]    [3x2 double]    [2x2 double]

  Columns 9 through 12

    [1x2 double]    [1x2 double]    [1x2 double]    [1x2 double]

  Column 13

    [1x2 double]

K>> cp2

cp2 = 

  Columns 1 through 4

    [1x2 double]    [1x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [1x2 double]    [2x2 double]    [1x2 double]

  Columns 9 through 12

    [1x2 double]    [2x2 double]    [1x2 double]    [1x2 double]

  Column 13

    [1x2 double]

K>> cp3

cp3 = 

  Columns 1 through 4

    [1x2 double]    [1x2 double]    [2x2 double]    [2x2 double]

  Columns 5 through 8

    [1x2 double]    [1x2 double]    [2x2 double]    [1x2 double]

  Columns 9 through 12

    [1x2 double]    [2x2 double]    [1x2 double]    [1x2 double]

  Column 13

    [1x2 double]

K>> tf{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> 
K>> 
K>>                 idx = tf{mBase}(STABLE_CNTRS{mBase});

                idx = tf{mBase}(STABLE_CNTRS{mBase});
K>> 
K>> idx

idx = 

  Columns 1 through 6

    [2x1 logical]    [1]    [2x1 logical]    [2x1 logical]    [1]    [1]

  Columns 7 through 13

    [3x1 logical]    [2x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> 
K>> idx[1}
 idx[1}
   |
Error: Unbalanced or unexpected parenthesis or bracket.
 
K>> idx{1}

ans =

     0
     1

K>> kLoc{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [2x1 double]    [2x1 double]    [1]    [2x1 double]

  Columns 7 through 12

    [0x1 double]    [2x1 double]    [2x1 double]    [2x1 double]    [1]    [1]

  Columns 13 through 18

    [3x1 double]    [2x1 double]    [0x1 double]    [3x1 double]    [1]    [2]

  Columns 19 through 21

    [1]    [1]    [1]

K>> kLoc{1}{3}

ans =

     0
     0

K>> kLoc{1}{4}

ans =

     0
     1

K>> idx

idx = 

  Columns 1 through 6

    [2x1 logical]    [1]    [2x1 logical]    [2x1 logical]    [1]    [1]

  Columns 7 through 13

    [3x1 logical]    [2x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> 
K>> 
K>> 
K>> 
K>> 
dbquit
>> clear all
dbstop at 63 in StableCntrs.m
>> load ../temp/poolOffset_cntrs.mat
dbstop at 63 in StableCntrs.m
>> StableCntrs
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, tf{mBase}));
dbstep 1
The result of calling the static method or constructor "tf" cannot be indexed
with cell array indexing.

Error in StableCntrs (line 63)
        STABLE_CELLS{mBase}  = logical(cellfun(@sum, tf{mBase}));
 
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, tf{mBase}));
K>> whos tf
K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> 
dbstop at 63 in StableCntrs.m
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, tf{mBase}));
dbstep 1
The result of calling the static method or constructor "tf" cannot be indexed
with cell array indexing.

Error in StableCntrs (line 63)
        STABLE_CELLS{mBase}  = logical(cellfun(@sum, tf{mBase}));
 
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, tf{mBase}));
K>> which tf
/usr/local/share/matlab/R2011b/toolbox/control/control/@tf/tf.m  % tf constructor
K>> dbquit
>> 
>> cear all
Undefined function 'cear' for input arguments of type 'char'.
 
>> clear all
>> load ../temp/poolOffset_cntrs.mat
dbstop at 63 in StableCntrs.m
>> StableCntrs
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
dbstep 1
Undefined variable "mTF" or class "mTF".

Error in StableCntrs (line 63)
        STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
 
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
K>> 
K>> whos 
  Name               Size             Bytes  Class              Attributes

  DetectCmnPks       1x1                 32  function_handle              
  cntrPeak           1x17              2304  cell                         
  cntrPeak1          1x17              2272  cell                         
  cntrPeakNames      2x1                258  cell                         
  evalStr            1x19                38  char                         
  kLoc               1x1               2216  cell                         
  kPr                1x1                  8  double                       
  kTF                1x1               2041  cell                         
  kTrPr              1x1                  8  double                       
  lTr                1x1                  8  double                       
  mBase              1x1                  8  double                       
  mTrPr              0x0                  0  double                       
  nTrPairs           1x1                  8  double                       
  nTrs               3x1                 24  double                       
  out                3x3             140064  cell                         
  trPairs            1x2                 16  double                       

K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Undefined variable "mTF" or class "mTF".

Error in StableCntrs (line 63)
        STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
 
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
dbstop at 52 in StableCntrs.m
K>> dbquit
dbstop at 52 in StableCntrs.m
>> StableCntrs
52          nTrPairs = size(trPairs, 1);
dbstep 1
53          for mTrPr = 1 : nTrPairs - 1
dbstep 1
63          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
K>> nTrPairs

nTrPairs =

     1

K>> 
K>> nTrPairs

nTrPairs =

     1

K>> trPairs

trPairs =

     1     2

K>> 
K>> kTrPr

kTrPr =

     1

K>> kTF

kTF = 

    {1x17 cell}

K>> 
K>> kTF

kTF = 

    {1x17 cell}

K>> 
K>> dbquti
Undefined function or variable 'dbquti'.
 
dbquit
dbstop at 66 in StableCntrs.m
>> clear all
>> load ../temp/poolOffset_cntrs.mat
dbstop at 66 in StableCntrs.m
>> StableCntrs
66          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
dbstep 1
67          for mTr = 1 : nTrs(mBase)
K>> SUM
Undefined function or variable 'SUM'.
 
K>> STABLE_CELLS

STABLE_CELLS = 

    [1x17 logical]

K>> 
dbstep 1
68              if mTr == 1
dbstep 1
69                  idx = tf{mBase}(STABLE_CNTRS{mBase});
dbstep 1
Undefined variable "STABLE_CNTRS" or class "STABLE_CNTRS".

Error in StableCntrs (line 69)
                idx = tf{mBase}(STABLE_CNTRS{mBase});
 
69                  idx = tf{mBase}(STABLE_CNTRS{mBase});
K>> 
K>> 
K>> 
K>> dbquit
>> STABLE_CELLS

STABLE_CELLS = 

    [1x17 logical]

dbstop at 66 in StableCntrs.m
>> StableCntrs
66          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
dbstep 1
67          for mTr = 1 : nTrs(mBase)
dbstep 1
68              if mTr == 1
dbstep 1
69                  idx = tf{mBase}(STABLE_CELLS{mBase});
dbstep 1
The result of calling the static method or constructor "tf" cannot be indexed
with cell array indexing.

Error in StableCntrs (line 69)
                idx = tf{mBase}(STABLE_CELLS{mBase});
 
69                  idx = tf{mBase}(STABLE_CELLS{mBase});
K>> 
K>> 
K>> dbquit
dbstop at 66 in StableCntrs.m
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 71)
                idx = kLoc{mTr}(STABLE_CELLS{mBase});
 
71                  idx = kLoc{mTr}(STABLE_CELLS{mBase});
K>> 
K>> mTr

mTr =

     2

K>> kLoc

kLoc = 

    {1x17 cell}

K>> dbquit
dbstop at 66 in StableCntrs.m
>> StableCntrs
66          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
dbstep 1
67          for mTr = 1 : nTrs(mBase)
K>> 
K>> 
K>> dbquit
dbstop at 66 in StableCntrs.m
>> StableCntrs
66          STABLE_CELLS{mBase}  = logical(cellfun(@sum, mTF{mBase}));
dbstep 1
67          for mTr = 1 : nTrs(mBase)
K>> trPairs

trPairs =

     1     2

K>> mTr

mTr =

     2

K>> 
K>> 
K>> trPairs

trPairs =

     1     2

K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
dbquit
>> clear all
dbstop at 73 in StableCntrs.m
>> StableCntrs
Undefined function or variable 'out'.

Error in StableCntrs (line 28)
    out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
 
28      out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
K>> dbquit
>> load ../temp/poolOffset_cntrs.mat
dbstop at 67 in StableCntrs.m
>> StableCntrs
67          for mTrPr = 1 : nTrPairs
dbstep 1
68              if mTrPr== 1
dbstep 1
69                  idx = mTF{mBase}(STABLE_CELLS{mBase});
dbstep 1
73              for kPr = 1 : 2
K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

dbstep 1
74                  cntrVertices = out{mBase, trPairs(kPr)}.cntrVertices(STABLE_CELLS{mBase});
dbstep 1
75                  cntrPeaks = out{mBase, trPairs(kPr)}.cntrPeals(STABLE_CELLS{mBase});
dbstep 1
77                  nStableCells = sum(STABLE_CELLS{mBase});
dbstep 1
78                  nStableCntrs = cellfun(@sum, mTF{mBase});
dbstep 1
79                  for kCell = 1 : nStableCells
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      kIdx(kIdx == 0) = [];
K>> kIdx

kIdx =

     0
     1

K>> 
K>> kTF

kTF = 

    {1x17 cell}

K>> kLoc

kLoc = 

    {1x17 cell}

K>> kLoc{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

K>> 
K>> 
K>> 
dbstep 1
82                      tempCntr = cntrVertices{kCell};
K>> kIdx

kIdx =

     1

K>> kCell

kCell =

     1

K>> idx{1}

ans =

     0
     1

K>> dbquit
dbstop at 79 in StableCntrs.m
>> StableCntrs
79                  for kCell = 1 : nStableCells
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      if kPr ~= 1, kIdx(kIdx == 0) = []; end
dbstep 1
82                      tempCntr = cntrVertices{kCell};
dbstep 1
83                      cmnCntrs.cntrVertices{mBase, trPairs(kPr)} = tempCntr(kIdx);
K>> tempCntr

tempCntr = 

    [29x2 double]    [31x2 double]

dbstep 1
84                  end
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      if kPr ~= 1, kIdx(kIdx == 0) = []; end
K>> kIdx

kIdx =

     1
     0

K>> nStableCells

nStableCells =

     2

dbstep 1
82                      tempCntr = cntrVertices{kCell};
dbstep 1
83                      cmnCntrs.cntrVertices{mBase, trPairs(kPr)} = tempCntr(kIdx);
dbstep 1
84                  end
dbstep 1
85              end
dbstep 1
74                  cntrVertices = out{mBase, trPairs(kPr)}.cntrVertices(STABLE_CELLS{mBase});
dbstep 1
75                  cntrPeaks = out{mBase, trPairs(kPr)}.cntrPeals(STABLE_CELLS{mBase});
dbstep 1
77                  nStableCells = sum(STABLE_CELLS{mBase});
K>> mTrPr

mTrPr =

     1

K>> cntrPeals
Undefined function or variable 'cntrPeals'.
 
K>> cntrPeaks

cntrPeaks = 

    [1x2 double]    [1x2 double]

dbstep 1
78                  nStableCntrs = cellfun(@sum, mTF{mBase});
dbstep 1
79                  for kCell = 1 : nStableCells
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      if kPr ~= 1, kIdx(kIdx == 0) = []; end
dbstep 1
82                      tempCntr = cntrVertices{kCell};
dbstep 1
83                      cmnCntrs.cntrVertices{mBase, trPairs(kPr)} = tempCntr(kIdx);
dbstep 1
84                  end
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      if kPr ~= 1, kIdx(kIdx == 0) = []; end
K>> dbstep 1
82                      tempCntr = cntrVertices{kCell};
dbstep 1
83                      cmnCntrs.cntrVertices{mBase, trPairs(kPr)} = tempCntr(kIdx);
dbstep 1
84                  end
dbstep 1
85              end
dbstep 1
86          end
dbstep 1
87      end
dbstep 1
35          DetectCmnPks = GenDetectCmnPks(2, 'ismemberf', 3);
K>> cmnCntrs

cmnCntrs = 

    cntrVertices: {{1x1 cell}  {1x1 cell}}

K>> cmnCntrs.cntrVertices

ans = 

    {1x1 cell}    {1x1 cell}

K>> mBase

mBase =

     2

K>> cmnCntrs.cntrVertices{1}

ans = 

    [37x2 double]

K>> cmnCntrs.cntrVertices{2}

ans = 

    [44x2 double]

K>> fogire
Undefined function or variable 'fogire'.
 
K>> figure
K>> c1 = cmnCntrs.cntrVertices{1}

c1 = 

    [37x2 double]

K>> c1 = cmnCntrs.cntrVertices{1}{1};
K>> whos c1
  Name       Size            Bytes  Class     Attributes

  c1        37x2               592  double              

K>> c2 = cmnCntrs.cntrVertices{2}{1};
K>> whos c*
  Name                Size            Bytes  Class     Attributes

  c1                 37x2               592  double              
  c2                 44x2               704  double              
  cmnCntrs            1x1              1920  struct              
  cntrPeak            1x17             2304  cell                
  cntrPeak1           1x17             2272  cell                
  cntrPeakNames       2x1               258  cell                
  cntrPeaks           1x2               256  cell                
  cntrVertices        1x2              1680  cell                

K>> plot(c1(:,1), c1(:,2))
K>> hold on
K>> xlim([1 50])
K>> ylim([1 50])
K>> hold on
K>> plot(c2(:,1), c2(:,2),'r')
K>> 
K>> grid
K>> 
K>> dbquit
dbstop at 79 in StableCntrs.m
>> StableCntrs
79                  for kCell = 1 : nStableCells
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      if kPr ~= 1, kIdx(kIdx == 0) = []; end
K>> dbstep 1
82                      tempCntr = cntrVertices{kCell};
dbstep 1
83                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
dbstep 1
Cell contents assignment to a non-cell array object.

Error in StableCntrs (line 83)
                    cmnCntrs{mBase, trPairs(kPr)}.cntrVertices =
                    tempCntr(kIdx);
 
83                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
dbstep 1
dbstep 1
Error using dbstep
Debug commands only allowed when stopped in debug mode.
 
dbstep 1
Error using dbstep
Debug commands only allowed when stopped in debug mode.
 
>> clear all
>> load ../temp/poolOffset_cntrs.mat
dbstop at 79 in StableCntrs.m
>> StableCntrs
79                  for kCell = 1 : nStableCells
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      if kPr ~= 1, kIdx(kIdx == 0) = []; end
K>> dbstep 1
82                      tempCntr = cntrVertices{kCell};
dbstep 1
83                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
dbstep 1
84                  end
dbstep 1
80                      kIdx = idx{kCell};
dbstep 1
81                      if kPr ~= 1, kIdx(kIdx == 0) = []; end
K>> dbstep 1
82                      tempCntr = cntrVertices{kCell};
K>> dbstep 1
83                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
dbstep 1
84                  end
dbstep 1
85              end
dbstep 1
74                  cntrVertices = out{mBase, trPairs(kPr)}.cntrVertices(STABLE_CELLS{mBase});
K>> 
K>> 
K>> 
K>> 
K>> kLoc

kLoc = 

    {1x17 cell}

K>> kLoc{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [0]    [0]    [2x1 double]    [3x1 double]

  Columns 7 through 12

    [0x1 double]    [3x1 double]    [0]    [0]    [4x1 double]    [0x1 double]

  Columns 13 through 17

    [2x1 double]    [0]    [0]    [2x1 double]    [2x1 double]

K>> mTF

mTF = 

    {1x17 cell}

K>> mTF{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

K>> mTF{end}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

K>> mTF{1}{end}

ans =

     1
     0

K>> kLoc{1}{end}

ans =

     1
     0

K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> 
K>> kLoc

kLoc = 

    {1x17 cell}

K>> 
K>> 
K>> 
K>> kLoc{1}{1}

ans =

     0

K>> kLoc{1}{2}

ans =

   Empty matrix: 0-by-1

K>> kLoc{1}{end}

ans =

     1
     0

K>> mTF

mTF = 

    {1x17 cell}

K>> mTF{end}{1}

ans =

     0

K>> mTF{1}{end}

ans =

     1
     0

K>> 
K>> 
K>> 
K>> 
K>> 
K>> mTF

mTF = 

    {1x17 cell}

K>> mTF{1}

ans = 

  Columns 1 through 6

    [0]    [0x1 logical]    [0]    [0]    [2x1 logical]    [3x1 logical]

  Columns 7 through 11

    [0x1 logical]    [3x1 logical]    [0]    [0]    [4x1 logical]

  Columns 12 through 16

    [0x1 logical]    [2x1 logical]    [0]    [0]    [2x1 logical]

  Column 17

    [2x1 logical]

K>> mTF

mTF = 

    {1x17 cell}

K>> 
K>> 
K>> 
K>> 
K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
The result of calling the static method or constructor "tf" cannot be indexed
with cell array indexing.

Error in StableCntrs (line 58)
                    mTF{mBase} = cellfun(@and, tf{mBase}, kTF{mTrPr +
                    1},'UNIFORMOUTPUT', 0);
 
58                      mTF{mBase} = cellfun(@and, tf{mBase}, kTF{mTrPr + 1},'UNIFORMOUTPUT', 0);
K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 58)
                    mTF{mBase} = cellfun(@and, kTF{mBase}, kTF{mTrPr +
                    1},'UNIFORMOUTPUT', 0);
 
58                      mTF{mBase} = cellfun(@and, kTF{mBase}, kTF{mTrPr + 1},'UNIFORMOUTPUT', 0);
K>> mBase

mBase =

     2

K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}

K>> mTrPr

mTrPr =

     2

K>> mBase

mBase =

     2

K>>                     mTF{mBase} = cellfun(@and, mTF{mBase}, kTF{mTrPr + 1},'UNIFORMOUTPUT', 0);

    
                    mTF{mBase} = cellfun(@and, mTF{mBase}, kTF{mTrPr + 1},'UNIFORMOUTPUT', 0);
Index exceeds matrix dimensions.
 
K>> 
K>>     
K>> mTF

mTF = 

    {1x17 cell}    {1x21 cell}

K>> kTF

kTF = 

    {1x21 cell}    {1x21 cell}

K>> mTrPr

mTrPr =

     2

K>> nTrPairs

nTrPairs =

     2

K>> trPairs

trPairs =

     1     2
     1     3

K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
dbstop at 67 in StableCntrs.m
>> STABLECNTRS
Cannot find an exact (case-sensitive) match for 'STABLECNTRS'.
Do you want: StableCntrs
(in /data/homes/shrisha/thesis/scripts/tempScripts/StableCntrs.m)?

 
>> STABLE_CELLS

STABLE_CELLS = 

    [1x17 logical]    [1x21 logical]    [1x12 logical]

>> STABLE_CELLS{3}

ans =

     1     0     1     1     1     0     1     0     1     1     0     1

>> STABLE_CELLS{2}

ans =

  Columns 1 through 13

     0     0     0     1     1     1     0     1     0     0     1     1     1

  Columns 14 through 21

     1     0     0     1     1     1     1     1

>> clear all
dbstop at 69 in StableCntrs.m
>> dbstop if error
dbstop at 70 in StableCntrs.m
>> STABLE_CELLS{2}
Undefined variable "STABLE_CELLS" or class "STABLE_CELLS".
 
>> StableCntrs
Undefined function or variable 'out'.

Error in StableCntrs (line 28)
    out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
 
28      out = out(logical(sum(~cellfun(@isempty, out), 2)), :); % remove empty rows
K>> dbquit
>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Undefined function or variable 'nCells'.

Error in StableCntrs (line 74)
                for lCell = 1 : nCells
 
74                  for lCell = 1 : nCells
dbstop at 74 in StableCntrs.m
K>> dbquit
>> clear all
dbquit
Error using dbquit
Debug commands only allowed when stopped in debug mode.
 
>> load ../temp/poolOffset_cntrs.mat
dbstop at 74 in StableCntrs.m
>> StableCntrs
74                  for lCell = 1 : nStableCells
dbstep 1
75                      for mCntr = 1 : nStableCntrs
dbstep 1
79                  end
K>> nStableCntrs

nStableCntrs =

  Columns 1 through 13

     0     0     0     1     1     2     0     2     0     0     1     1     1

  Columns 14 through 21

     1     0     0     1     1     1     1     1

dbstep 1
75                      for mCntr = 1 : nStableCntrs
dbstep 1
79                  end
dbstep 1
75                      for mCntr = 1 : nStableCntrs
dbstep 1
79                  end
dbstep 1
75                      for mCntr = 1 : nStableCntrs
dbstep 1
79                  end
dbstep 1
75                      for mCntr = 1 : nStableCntrs
dbstep 1
79                  end
K>> nStableCntrs

nStableCntrs =

  Columns 1 through 13

     0     0     0     1     1     2     0     2     0     0     1     1     1

  Columns 14 through 21

     1     0     0     1     1     1     1     1

K>> nStableCntrs

nStableCntrs =

  Columns 1 through 13

     0     0     0     1     1     2     0     2     0     0     1     1     1

  Columns 14 through 21

     1     0     0     1     1     1     1     1

K>> nStableCell
Undefined function or variable 'nStableCell'.
 
K>> nStableCells

nStableCells =

    13

K>> mBase

mBase =

     2

dbstep 1
75                      for mCntr = 1 : nStableCntrs
dbstep 1
79                  end
dbstep 1
75                      for mCntr = 1 : nStableCntrs
dbstep 1
79                  end
K>> mCntr

mCntr =

     []

K>> nStableCntrs

nStableCntrs =

  Columns 1 through 13

     0     0     0     1     1     2     0     2     0     0     1     1     1

  Columns 14 through 21

     1     0     0     1     1     1     1     1

K>> kLoc

kLoc = 

    {1x21 cell}    {1x21 cell}

K>> trPairs

trPairs =

     1     2
     1     3

K>> mTF

mTF = 

    {1x17 cell}    {1x21 cell}

K>> mTF{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> mBase

mBase =

     2

K>> trPairs

trPairs =

     1     2
     1     3

K>> kLoc

kLoc = 

    {1x21 cell}    {1x21 cell}

K>> kLoc{2}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [2x1 double]    [2x1 double]    [1]    [2x1 double]

  Columns 7 through 12

    [0x1 double]    [2x1 double]    [2x1 double]    [2x1 double]    [1]    [1]

  Columns 13 through 18

    [3x1 double]    [2x1 double]    [0x1 double]    [3x1 double]    [1]    [1]

  Columns 19 through 21

    [1]    [1]    [1]

K>> kLoc{2}}(STABLE_CELLS{mBase})
 kLoc{2}}(STABLE_CELLS{mBase})
       |
Error: Unbalanced or unexpected parenthesis or bracket.
 
K>> kLoc{2}(STABLE_CELLS{mBase})

ans = 

  Columns 1 through 6

    [2x1 double]    [1]    [2x1 double]    [2x1 double]    [1]    [1]

  Columns 7 through 13

    [3x1 double]    [2x1 double]    [1]    [1]    [1]    [1]    [1]

K>> nStableCntrs

nStableCntrs =

  Columns 1 through 13

     0     0     0     1     1     2     0     2     0     0     1     1     1

  Columns 14 through 21

     1     0     0     1     1     1     1     1

K>> nStableCells

nStableCells =

    13

K>> kLoc{2}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [2x1 double]    [2x1 double]    [1]    [2x1 double]

  Columns 7 through 12

    [0x1 double]    [2x1 double]    [2x1 double]    [2x1 double]    [1]    [1]

  Columns 13 through 18

    [3x1 double]    [2x1 double]    [0x1 double]    [3x1 double]    [1]    [1]

  Columns 19 through 21

    [1]    [1]    [1]

K>> kLoc{2}{3}

ans =

     0
     0

K>> kLoc{2}{4}

ans =

     0
     2

K>> mTF

mTF = 

    {1x17 cell}    {1x21 cell}

K>> mTF{2}

ans = 

  Columns 1 through 5

    [0]    [0x1 logical]    [2x1 logical]    [2x1 logical]    [1]

  Columns 6 through 9

    [2x1 logical]    [0x1 logical]    [2x1 logical]    [2x1 logical]

  Columns 10 through 14

    [2x1 logical]    [1]    [1]    [3x1 logical]    [2x1 logical]

  Columns 15 through 21

    [0x1 logical]    [3x1 logical]    [1]    [1]    [1]    [1]    [1]

K>> mTF{2}{4}

ans =

     0
     1

K>> kLoc

kLoc = 

    {1x21 cell}    {1x21 cell}

K>> idx

idx = 

  Columns 1 through 6

    [2x1 double]    [1]    [2x1 double]    [2x1 double]    [1]    [1]

  Columns 7 through 13

    [3x1 double]    [2x1 double]    [1]    [1]    [1]    [1]    [1]

K>> idx{1}

ans =

     0
     2

K>> dbquit
>> clear all
>> dbquit
Error using dbquit
Debug commands only allowed when stopped in debug mode.
 
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Undefined function or variable 'nCntr'.

Error in StableCntrs (line 77)
                        idx{lCell}{nCntr} = tempKloc(mTF{mBase}{lCell});
 
77                          idx{lCell}{nCntr} = tempKloc(mTF{mBase}{lCell});
K>> tempKloc(mTF{mBase}{lCell})

ans =

     []

K>> tempKloc

tempKloc =

     0

K>> dbqui
Undefined function or variable 'dbqui'.
 
dbquit
>> StableCntrs
Undefined function or variable 'nCntr'.

Error in StableCntrs (line 77)
                        idx{lCell}{nCntr} = tempKloc(mTF{mBase}{lCell});
 
77                          idx{lCell}{nCntr} = tempKloc(mTF{mBase}{lCell});
K>> dbquit
>> nStableCells

nStableCells =

    13

>> nStableCntrs

nStableCntrs =

    15

dbstop at 77 in StableCntrs.m
>> StableCntrs
77                          idx{lCell} = tempKloc(mTF{mBase}{lCell});
K>> tempKloc(mTF{mBase}{lCell})

ans =

     []

K>> tempKloc

tempKloc =

     0

dbstep 1
79                  end
dbstep 1
76                          tempKloc = kLoc{mTrPr}{lCell};
dbstep 1
77                          idx{lCell} = tempKloc(mTF{mBase}{lCell});
K>> tempKloc

tempKloc =

   Empty matrix: 0-by-1

dbstep 1
79                  end
dbstep 1
76                          tempKloc = kLoc{mTrPr}{lCell};
dbstep 1
77                          idx{lCell} = tempKloc(mTF{mBase}{lCell});
K>> templates
Undefined function or variable 'templates'.
 
K>> kLoc{mTrPr}

ans = 

  Columns 1 through 6

    [0]    [0x1 double]    [2x1 double]    [2x1 double]    [1]    [2x1 double]

  Columns 7 through 12

    [0x1 double]    [2x1 double]    [2x1 double]    [2x1 double]    [1]    [1]

  Columns 13 through 18

    [3x1 double]    [2x1 double]    [0x1 double]    [3x1 double]    [1]    [1]

  Columns 19 through 21

    [1]    [1]    [1]

K>> kLoc{mTrPr}{4}

ans =

     0
     2

K>> lCell

lCell =

     3

dbstep 1
79                  end
dbstep 1
76                          tempKloc = kLoc{mTrPr}{lCell};
dbstep 1
77                          idx{lCell} = tempKloc(mTF{mBase}{lCell});
K>> lCell

lCell =

     4

K>> tempKloc

tempKloc =

     0
     2

K>> mTF{mBase}{lCell}

ans =

     0
     1

dbstep 1
79                  end
K>> idx

idx = 

  Columns 1 through 7

    []    [0x1 double]    [0x1 double]    [2]    [1]    [1]    [3x1 double]

  Columns 8 through 13

    [2x1 double]    [1]    [1]    [1]    [1]    [1]

dbstep 1
76                          tempKloc = kLoc{mTrPr}{lCell};
dbstep 1
77                          idx{lCell} = tempKloc(mTF{mBase}{lCell});
dbstep 1
79                  end
K>> tempKloc

tempKloc =

     1

K>> idx

idx = 

  Columns 1 through 7

    []    [0x1 double]    [0x1 double]    [2]    [1]    [1]    [3x1 double]

  Columns 8 through 13

    [2x1 double]    [1]    [1]    [1]    [1]    [1]

K>> dbclear all
dbcont
>> idx

idx = 

  Columns 1 through 5

    [2x1 logical]    [3x1 logical]    [1]    [4x1 logical]    [2x1 logical]

  Columns 6 through 8

    [1]    [3x1 logical]    [1]

>> idx{1}

ans =

     0
     1

>> idx{2}

ans =

     1
     1
     1

>> idx{3}

ans =

     1

dbstop at 80 in StableCntrs.m
>> StableCntrs
80                  cntrVertices = out{mBase, trPairs(kPr)}.cntrVertices(STABLE_CELLS{mBase});
dbstep 1
81                  cntrPeaks = out{mBase, trPairs(kPr)}.cntrPeals(STABLE_CELLS{mBase});
dbstep 1
83                  for kCell = 1 : nStableCells
K>> cntrVertices

cntrVertices = 

    {1x2 cell}    {1x2 cell}

K>> mTrPr

mTrPr =

     1

K>> trPairs

trPairs =

     1     2

K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

dbstep 1
84                      kIdx = idx{kCell};
dbstep 1
86                      tempCntr = cntrVertices{kCell};
dbstep 1
87                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
dbstep 1
88                  end
dbstep 1
84                      kIdx = idx{kCell};
dbstep 1
86                      tempCntr = cntrVertices{kCell};
dbstep 1
87                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
dbstep 1
88                  end
dbstep 1
89              end
dbstep 1
80                  cntrVertices = out{mBase, trPairs(kPr)}.cntrVertices(STABLE_CELLS{mBase});
dbstep 1
81                  cntrPeaks = out{mBase, trPairs(kPr)}.cntrPeals(STABLE_CELLS{mBase});
dbstep 1
83                  for kCell = 1 : nStableCells
dbstep 1
84                      kIdx = idx{kCell};
dbstep 1
86                      tempCntr = cntrVertices{kCell};
dbstep 1
87                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
dbstep 1
Index exceeds matrix dimensions.

Error in StableCntrs (line 87)
                    cmnCntrs{mBase, trPairs(kPr)}.cntrVertices =
                    tempCntr(kIdx);
 
>> dbstop if error
>> kIdx

kIdx =

     0
     1

>> tempCntr

tempCntr = 

    [33x2 double]

>> kCell

kCell =

     1

>> clear all
>> load ../temp/poolOffset_cntrs.mat
>> StableCntrs
Index exceeds matrix dimensions.

Error in StableCntrs (line 87)
                    cmnCntrs{mBase, trPairs(kPr)}.cntrVertices =
                    tempCntr(kIdx);
 
87                      cmnCntrs{mBase, trPairs(kPr)}.cntrVertices = tempCntr(kIdx);
K>> mBase

mBase =

     1

K>> kCell

kCell =

     1

K>> 
K>> kidx
Undefined function or variable 'kidx'.
 
K>> kIdx

kIdx =

     0
     1

K>> idx

idx = 

    [2x1 logical]    [2x1 logical]

K>> idx{1}

ans =

     0
     1

K>> idx{2}

ans =

     1
     0

K>> cntrVertices

cntrVertices = 

    {1x1 cell}    {1x1 cell}

K>> dbquit
>> 